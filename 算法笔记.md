## STL 容器操作汇总（增删改查、排序等）

以下是常见 STL 容器的**增删改查、排序等操作**的汇总，并标注了操作的**返回值**（若无返回值则标注"无"）。

------

### 1. 顺序容器（Sequence Containers）

### **(1)** `**vector**`**（动态数组）**

| 操作             | 代码示例                      | 返回值                                     | 时间复杂度 |
| ---------------- | ----------------------------- | ------------------------------------------ | ---------- |
| **添加元素**     | `v.push_back(x)`              | 无                                         | O(1)       |
| **插入元素**     | `v.insert(it, x)`             | 返回指向新元素的迭代器                     | O(n)       |
| **删除末尾**     | `v.pop_back()`                | 无                                         | O(1)       |
| **删除指定位置** | `v.erase(it)`                 | 返回删除后的下一个元素的迭代器             | O(n)       |
| **查找元素**     | `find(v.begin(), v.end(), x)` | 返回指向元素的迭代器（未找到返回 `end()`） | O(n)       |
| **排序**         | `sort(v.begin(), v.end())`    | 无                                         | O(n log n) |
| **随机访问**     | `v[i]`                        | 返回对应位置的引用                         | O(1)       |

### **(2)** `**deque**`**（双端队列）**

| 操作         | 代码示例                   | 返回值                         | 时间复杂度 |
| ------------ | -------------------------- | ------------------------------ | ---------- |
| **头部插入** | `d.push_front(x)`          | 无                             | O(1)       |
| **尾部插入** | `d.push_back(x)`           | 无                             | O(1)       |
| **头部删除** | `d.pop_front()`            | 无                             | O(1)       |
| **尾部删除** | `d.pop_back()`             | 无                             | O(1)       |
| **插入元素** | `d.insert(it, x)`          | 返回指向新元素的迭代器         | O(n)       |
| **删除元素** | `d.erase(it)`              | 返回删除后的下一个元素的迭代器 | O(n)       |
| **排序**     | `sort(d.begin(), d.end())` | 无                             | O(n log n) |

### **(3)** `**list**`**（双向链表）**

| 操作         | 代码示例          | 返回值                         | 时间复杂度 |
| ------------ | ----------------- | ------------------------------ | ---------- |
| **头部插入** | `l.push_front(x)` | 无                             | O(1)       |
| **尾部插入** | `l.push_back(x)`  | 无                             | O(1)       |
| **头部删除** | `l.pop_front()`   | 无                             | O(1)       |
| **尾部删除** | `l.pop_back()`    | 无                             | O(1)       |
| **插入元素** | `l.insert(it, x)` | 返回指向新元素的迭代器         | O(1)       |
| **删除元素** | `l.erase(it)`     | 返回删除后的下一个元素的迭代器 | O(1)       |
| **排序**     | `l.sort()`        | 无                             | O(n log n) |
| **合并链表** | `l1.merge(l2)`    | 无                             | O(n)       |

------

### 2. 关联容器（Associative Containers）

### **(1)** `**set**` **/** `**multiset**`**（有序集合）**

| 操作         | 代码示例           | 返回值                                          | 时间复杂度 |
| ------------ | ------------------ | ----------------------------------------------- | ---------- |
| **插入元素** | `s.insert(x)`      | `pair<iterator, bool>`（`multiset` 返回迭代器） | O(log n)   |
| **删除元素** | `s.erase(x)`       | 返回删除的元素个数                              | O(log n)   |
| **查找元素** | `s.find(x)`        | 返回指向元素的迭代器（未找到返回 `end()`）      | O(log n)   |
| **统计元素** | `s.count(x)`       | 返回元素个数                                    | O(log n)   |
| **范围查询** | `s.lower_bound(x)` | 返回第一个 ≥x 的迭代器                          | O(log n)   |
| **范围查询** | `s.upper_bound(x)` | 返回第一个 >x 的迭代器                          | O(log n)   |

### **(2)** `**map**` **/** `**multimap**`**（有序键值对）**

| 操作         | 代码示例           | 返回值                                          | 时间复杂度 |
| ------------ | ------------------ | ----------------------------------------------- | ---------- |
| **插入元素** | `m.insert({k, v})` | `pair<iterator, bool>`（`multimap` 返回迭代器） | O(log n)   |
| **删除元素** | `m.erase(k)`       | 返回删除的元素个数                              | O(log n)   |
| **查找元素** | `m.find(k)`        | 返回指向元素的迭代器（未找到返回 `end()`）      | O(log n)   |
| **访问元素** | `m[k]`             | 返回对应值的引用（若不存在则创建）              | O(log n)   |
| **统计元素** | `m.count(k)`       | 返回键的个数                                    | O(log n)   |
| **范围查询** | `m.lower_bound(k)` | 返回第一个 ≥k 的迭代器                          | O(log n)   |
| **范围查询** | `m.upper_bound(k)` | 返回第一个 >k 的迭代器                          | O(log n)   |

------

### 3. 无序容器（Unordered Containers）

### **(1)** `**unordered_set**` **/** `**unordered_multiset**`**（哈希集合）**

| 操作         | 代码示例       | 返回值                                                    | 时间复杂度           |
| ------------ | -------------- | --------------------------------------------------------- | -------------------- |
| **插入元素** | `us.insert(x)` | `pair<iterator, bool>`（`unordered_multiset` 返回迭代器） | 平均 O(1)，最坏 O(n) |
| **删除元素** | `us.erase(x)`  | 返回删除的元素个数                                        | 平均 O(1)，最坏 O(n) |
| **查找元素** | `us.find(x)`   | 返回指向元素的迭代器（未找到返回 `end()`）                | 平均 O(1)，最坏 O(n) |
| **统计元素** | `us.count(x)`  | 返回元素个数                                              | 平均 O(1)，最坏 O(n) |

### **(2)** `**unordered_map**` **/** `**unordered_multimap**`**（哈希映射）**

| 操作         | 代码示例            | 返回值                                                    | 时间复杂度           |
| ------------ | ------------------- | --------------------------------------------------------- | -------------------- |
| **插入元素** | `um.insert({k, v})` | `pair<iterator, bool>`（`unordered_multimap` 返回迭代器） | 平均 O(1)，最坏 O(n) |
| **删除元素** | `um.erase(k)`       | 返回删除的元素个数                                        | 平均 O(1)，最坏 O(n) |
| **查找元素** | `um.find(k)`        | 返回指向元素的迭代器（未找到返回 `end()`）                | 平均 O(1)，最坏 O(n) |
| **访问元素** | `um[k]`             | 返回对应值的引用（若不存在则创建）                        | 平均 O(1)，最坏 O(n) |
| **统计元素** | `um.count(k)`       | 返回键的个数                                              | 平均 O(1)，最坏 O(n) |

------

### 4. 容器适配器（Container Adaptors）

### **(1)** `**stack**`**（栈）**

| 操作         | 代码示例    | 返回值             | 时间复杂度 |
| ------------ | ----------- | ------------------ | ---------- |
| **入栈**     | `s.push(x)` | 无                 | O(1)       |
| **出栈**     | `s.pop()`   | 无                 | O(1)       |
| **访问栈顶** | `s.top()`   | 返回栈顶元素的引用 | O(1)       |

### **(2)** `**queue**`**（队列）**

| 操作         | 代码示例    | 返回值             | 时间复杂度 |
| ------------ | ----------- | ------------------ | ---------- |
| **入队**     | `q.push(x)` | 无                 | O(1)       |
| **出队**     | `q.pop()`   | 无                 | O(1)       |
| **访问队首** | `q.front()` | 返回队首元素的引用 | O(1)       |
| **访问队尾** | `q.back()`  | 返回队尾元素的引用 | O(1)       |

### **(3)** `**priority_queue**`**（优先队列）**

| 操作         | 代码示例     | 返回值             | 时间复杂度 |
| ------------ | ------------ | ------------------ | ---------- |
| **入队**     | `pq.push(x)` | 无                 | O(log n)   |
| **出队**     | `pq.pop()`   | 无                 | O(log n)   |
| **访问队首** | `pq.top()`   | 返回队首元素的引用 | O(1)       |

------

### 5. 总结

| 容器类别                                             | 适用场景               | 主要特点                     |
| ---------------------------------------------------- | ---------------------- | ---------------------------- |
| `**vector**`                                         | 动态数组，随机访问频繁 | 尾部操作快，中间插入/删除慢  |
| `**deque**`                                          | 双端队列，头尾操作频繁 | 头尾操作 O(1)，中间操作 O(n) |
| `**list**`                                           | 频繁插入/删除          | 插入/删除 O(1)，随机访问慢   |
| `**set**`**/**`**map**`                              | 有序存储，快速查找     | 插入/删除/查找 O(log n)      |
| `**unordered_set**`**/**`**unordered_map**`          | 哈希存储，快速查找     | 平均 O(1)，最坏 O(n)         |
| `**stack**`**/**`**queue**`**/**`**priority_queue**` | 特定数据结构           | 栈、队列、堆操作             |

**注**：

- `**insert**` **和** `**erase**` **通常返回迭代器**，用于后续操作。
- `**find**` **返回** `**end()**` **表示未找到**。
- `**map**` **的** `**operator[]**` **会自动创建不存在的键**，而 `at()` 会抛出异常。



## c++srand随机数

```cpp
#include <iostream>
#include <cstdlib>  // srand, rand
#include <ctime>    // time

int main() {
    // 设置随机种子（通常用当前时间）
    srand(time(nullptr));

    // 生成 1 到 99 的随机数
    int random_number = rand() % 99 + 1;

    // 输出结果
    std::cout << "随机数 (1-99): " << random_number << std::endl;

    return 0;
}
```

## oop实现顺序栈

```cpp
#include <iostream>
#include <string>  // 为了使用 std::string
using namespace std;

template <typename T>
class SeqStack {
public:
    SeqStack(int size = 10) {
        _pstack = new T[size];
        _top = -1;
        _size = size;
    }

    ~SeqStack() {
        delete[] _pstack;
        _pstack = nullptr;
    }

    void push(T val) {
        if (full()) {
            resize();
        }
        _pstack[++_top] = val;
    }

    void pop() {
        if (empty()) return;
        --_top;
    }

    T top() {
        return _pstack[_top];
    }

    bool empty() { return _top == -1; }
    bool full() { return _top == _size - 1; }

    void show() const {
        cout << _size << endl;
    }

private:
    T* _pstack;
    int _top;
    int _size;

    void resize() {
        T* ptmp = new T[_size * 2];
        for (int i = 0; i < _size; ++i) {
            ptmp[i] = _pstack[i];
        }
        delete[] _pstack;
        _pstack = ptmp;
        _size *= 2;
    }
};

int main() {
    SeqStack<int> s(25);  // 使用 int 类型的栈
    for (int i = 0; i < 30; ++i) {
        cout << i << " ";
        s.push(i);
    }
    for (int i = 0; i < 30; ++i) {
        cout << endl << s.top();
        s.pop();
    }
    s.show();

    cout << "Double type stack:" << endl;
    SeqStack<double> s2(10);  // 使用 double 类型的栈
    for (int i = 0; i < 5; ++i) {
        s2.push(i * 0.5);
        cout << "Pushed: " << i * 0.5 << endl;
    }
    for (int i = 0; i < 5; ++i) {
        cout << "Top: " << s2.top() << endl;
        s2.pop();
    }

    // 添加 string 类型的栈操作
    cout << "String type stack:" << endl;
    SeqStack<string> s3(10);  // 使用 string 类型的栈
    s3.push("Hello");
    s3.push("World");
    s3.push("C++ Templates");
    
    for (int i = 0; i < 3; ++i) {
        cout << "Top: " << s3.top() << endl;
        s3.pop();
    }

    return 0;
}
#include <iostream>
using namespace std;
class SeqStack
{
public:
    SeqStack(int size = 10) {
        _pstack = new int[size];
        _top = -1;
        _size = size;

    }

    ~SeqStack() {
        delete[]_pstack;
        _pstack = nullptr;
    }
    
    void push(int val) {
        if (full())
        {
            resize();
        }
        _pstack[++_top] = val;
    }
    void pop()
    {
        if (empty()) return;
        --_top;
    }
    int top()
    {
        return _pstack[_top];
    }

    bool empty() { return _top == -1; }
    bool full() { return _top == _size - 1; }
    void show() const
    {
        cout << _size << endl;
    }


private:
    int* _pstack;
    int _top;
    int _size;
    void resize()
    {
        int* ptmp = new int[_size * 2];
        for (int i = 0; i < _size; ++i)  //不要用memcpy(ptmp,_psatck,sizeof(int)*_size);以及realloc
                                         //内存的简单拷贝，要是是对象或指针会涉及到深浅拷贝问题！！！
        {
            ptmp[i] = _pstack[i];
        }
        delete[]_pstack;
        _pstack = ptmp;
        _size *= 2;
    }

};
int main()
{
    SeqStack s(25);
    for (int i = 0; i < 30; ++i)
    {
        cout << i << " "  ;
        s.push(i);
        //s.push(rand() % 100);
    }
    for (int i = 0; i < 30; ++i)
    {
        cout << endl<< s.top() ;
        s.pop();
    }
    s.show();


    return 0;
}
```



## oop实现vector（无空间配置器）

重要！！！：当vector<test>  vec;时，用new时，开辟内存为10时，会自动进行对对象的10次构造（因为默认vector起始大小为10），而实际存放的对象数量可能只有几个，所以空间配置器allocator的作用是将内存开辟跟构造析构分开！！！

```cpp
//定义自己的容器空间配置器，与C++标准库的allocator实现一样（小写）
template<typename T>
class Allocator
{
public:
    T* allocate(size_t size)  //开辟内存，但不构造
    {
        cout << "nihao " << endl;
        return (T*)malloc(sizeof(T) * size);
    }

    T* deallocate(void *p)  //内存释放
    {
        free(p);
    }

    void construct(T* p, const T& val)//负责对象构造
    {
        new (p) T(val);     //定位new，在开辟好的p上进行构造对象！
    }

    void destroy(T* p)    //析构对象
    {
        p->~T();//~T()代表T类型的析构函数
    }
};
#include <iostream>
#include <stdexcept> // for exceptions

template <typename T>
class Vector {
private:
    T* _first;   // 指向数据的开始
    T* _last;    // 指向当前存储的最后一个元素的后一个位置
    T* _end;     // 指向已分配空间的末尾

    // 扩容函数，使用 for 循环来迁移数据
    void resize(size_t newCapacity) {
        size_t currentSize = size();      // 获取当前元素个数
        T* newData = new T[newCapacity];  // 分配新空间

        // 使用 for 循环手动复制数据
        for (size_t i = 0; i < currentSize; ++i) {
            newData[i] = _first[i];
        }

        delete[] _first;                  // 释放旧空间
        _first = newData;                 // 更新指针
        _last = _first + currentSize;     // 更新当前大小
        _end = _first + newCapacity;      // 更新容量指针
    }

public:
    // 默认构造函数
    Vector() : _first(nullptr), _last(nullptr), _end(nullptr) {}

    // 拷贝构造函数，使用 for 循环来复制数据
    Vector(const Vector<T> & other) {
        size_t otherSize = other.size();
        _first = new T[otherSize];       // 分配与原 vector 大小相同的空间
        _last = _first + otherSize;
        _end = _last;

        // 使用 for 循环手动复制数据
        for (size_t i = 0; i < otherSize; ++i) {
            _first[i] = other._first[i];
        }
    }

    // 拷贝赋值操作符，使用 for 循环来复制数据
    Vector<T>& operator=(const Vector<T>& other) {
        if (this != &other) {  // 避免自赋值
            delete[] _first;   // 释放已有数据

            size_t otherSize = other.size();
            _first = new T[otherSize];   // 分配新空间
            _last = _first + otherSize;
            _end = _last;

            // 使用 for 循环手动复制数据
            for (size_t i = 0; i < otherSize; ++i) {
                _first[i] = other._first[i];
            }
        }
        return *this;
    }

    // 析构函数
    ~Vector() {
        delete[] _first;  // 释放内存
    }

    // 获取当前元素个数
    size_t size() const {
        return _last - _first;
    }

    // 获取容量
    size_t capacity() const {
        return _end - _first;
    }

    // 添加元素
    void push_back(const T& value) {
        if (_last == _end) {
            // 容量不够时扩容，初始时容量为 1，然后翻倍扩展
            size_t newCapacity = capacity() == 0 ? 1 : capacity() * 2;
            resize(newCapacity);
        }
        *_last = value;  // 插入元素
        ++_last;         // 增加元素个数
    }

    // 删除最后一个元素
    void pop_back() {
        if (_last > _first) {
            --_last;  // 减少元素个数
        } else {
            throw std::out_of_range("Vector is empty");
        }
    }

    // 下标访问运算符
    T& operator[](size_t index) {
        if (index >= size()) {
            throw std::out_of_range("Index out of bounds");
        }
        return _first[index];
    }

    // 常量版本的下标访问运算符
    const T& operator[](size_t index) const {
        if (index >= size()) {
            throw std::out_of_range("Index out of bounds");
        }
        return _first[index];
    }

    // 返回第一个元素
    T& front() {
        if (size() > 0) {
            return *_first;
        } else {
            throw std::out_of_range("Vector is empty");
        }
    }

    // 返回最后一个元素
    T& back() {
        if (size() > 0) {
            return *(_last - 1);
        } else {
            throw std::out_of_range("Vector is empty");
        }
    }

    // 清空容器
    void clear() {
        _last = _first;  // 不释放内存，只将大小置为 0
    }
};

int main() {
    Vector<int> vec;
    vec.push_back(1);
    vec.push_back(2);
    vec.push_back(3);

    std::cout << "Size: " << vec.size() << "\n";
    std::cout << "Capacity: " << vec.capacity() << "\n";

    for (size_t i = 0; i < vec.size(); ++i) {
        std::cout << "Element at " << i << ": " << vec[i] << "\n";
    }

    vec.pop_back();
    std::cout << "After pop_back, size: " << vec.size() << "\n";

    // 使用拷贝构造函数
    Vector<int> vecCopy(vec);
    std::cout << "Copy Size: " << vecCopy.size() << "\n";

    // 使用赋值操作符
    Vector<int> vecAssign;
    vecAssign = vec;
    std::cout << "Assign Size: " << vecAssign.size() << "\n";

    return 0;
}
#include <iostream>
#include <stdexcept> // for exceptions
#include <memory>  // for std::allocator
using namespace std;

template <typename T, typename Allocator = std::allocator<T>>
class Vector {
private:
    T* _first;   // 指向数据的开始
    T* _last;    // 指向当前存储的最后一个元素的后一个位置
    T* _end;     // 指向已分配空间的末尾
    Allocator alloc;  // 空间配置器

    // 扩容函数，使用 for 循环来迁移数据
    void resize(size_t newCapacity) {
        size_t currentSize = size();      // 获取当前元素个数
        T* newData = alloc.allocate(newCapacity);  // 分配新空间

        // 使用 for 循环手动复制数据
        for (size_t i = 0; i < currentSize; ++i) {
            alloc.construct(&newData[i], _first[i]);  // 使用分配器构造元素
        }

        // 销毁旧数据并释放内存
        for (size_t i = 0; i < currentSize; ++i) {
            alloc.destroy(&_first[i]);
        }
        alloc.deallocate(_first, capacity());

        _first = newData;                 // 更新指针
        _last = _first + currentSize;     // 更新当前大小
        _end = _first + newCapacity;      // 更新容量指针
    }

public:
    // 默认构造函数，初始化容量为 10
    Vector(int size = 10) : _first(nullptr), _last(nullptr), _end(nullptr) {
        _first = alloc.allocate(size);  // 分配初始容量为 10 的空间
        _last = _first;
        _end = _first + size;
    }

    // 拷贝构造函数，使用 for 循环来复制数据
    Vector(const Vector& other) {
        size_t otherSize = other.size();
        _first = alloc.allocate(otherSize);  // 分配与原 vector 大小相同的空间
        _last = _first + otherSize;
        _end = _last;

        // 使用 for 循环手动复制数据
        for (size_t i = 0; i < otherSize; ++i) {
            alloc.construct(&_first[i], other._first[i]);  // 使用分配器构造元素
        }
    }

    // 拷贝赋值操作符，使用 for 循环来复制数据
    Vector& operator=(const Vector& other) {
        if (this != &other) {  // 避免自赋值
            clear();           // 清空当前的元素
            alloc.deallocate(_first, capacity());  // 释放内存

            size_t otherSize = other.size();
            _first = alloc.allocate(otherSize);  // 分配新空间
            _last = _first + otherSize;
            _end = _last;

            // 使用 for 循环手动复制数据
            for (size_t i = 0; i < otherSize; ++i) {
                alloc.construct(&_first[i], other._first[i]);  // 使用分配器构造元素
            }
        }
        return *this;
    }

    // 析构函数
    ~Vector() {
        clear();  // 清空并销毁所有元素
        alloc.deallocate(_first, capacity());  // 释放内存
    }

    // 获取当前元素个数
    size_t size() const {
        return _last - _first;
    }

    // 获取容量
    size_t capacity() const {
        return _end - _first;
    }

    // 添加元素
    void push_back(const T& value) {
        if (_last == _end) {
            // 容量不够时扩容，初始时容量为 10，然后翻倍扩展
            size_t newCapacity = capacity() == 0 ? 10 : capacity() * 2;
            resize(newCapacity);
        }
        alloc.construct(_last, value);  // 使用分配器构造元素
        ++_last;         // 增加元素个数
    }

    // 删除最后一个元素
    void pop_back() {
        if (_last > _first) {
            --_last;  // 减少元素个数
            alloc.destroy(_last);  // 使用分配器销毁元素
        }
        else {
            throw std::out_of_range("Vector is empty");
        }
    }

    //// 下标访问运算符
    //T& operator[](size_t index) {
    //    if (index >= size()) {
    //        throw std::out_of_range("Index out of bounds");
    //    }
    //    return _first[index];
    //}

    //// 常量版本的下标访问运算符
    //const T& operator[](size_t index) const {
    //    if (index >= size()) {
    //        throw std::out_of_range("Index out of bounds");
    //    }
    //    return _first[index];
    //}

    // 返回第一个元素
    T& front() {
        if (size() > 0) {
            return *_first;
        }
        else {
            throw std::out_of_range("Vector is empty");
        }
    }

    // 返回最后一个元素
    T& back() {
        if (size() > 0) {
            return *(_last - 1);
        }
        else {
            throw std::out_of_range("Vector is empty");
        }
    }

    // 清空容器
    void clear() {
        while (_last != _first) {
            pop_back();  // 销毁所有元素
        }
    }
};


class test
{
private:
public:
    test() { cout << "构造函数" <<endl; }
    ~test() { cout << "析构函数" << endl; }
    test(const test&) { cout << "kaobei构造" << endl; }
};

int main() {

    Vector<test> ve(15);
    test v1,v2,v3;
    cout << "hhhhhhhhhhhhhhhhhhhhhhhhhhhhhh" << endl;
    ve.push_back(v1);
    ve.push_back(v2);
    ve.push_back(v3);
    cout << "hhhhhhhhhhhhhhhhhhhhhhhhhhhhhh" << endl;
    ve.pop_back( );
    cout << "hhhhhhhhhhhhhhhhhhhhhhhhhhhhhh" << endl;
    //Vector<int> vec;
    //for (int i = 1; i < 5; i++)
    //{
    //    vec.push_back(i);
    //}
    ////vec.push_back(1);
    ////vec.push_back(2);
    ////vec.push_back(3);

    //std::cout << "Size: " << vec.size() << "\n";
    //std::cout << "Capacity: " << vec.capacity() << "\n";

    //for (size_t i = 0; i < vec.size(); ++i) {
    //    std::cout << "Element at " << i << ": " << vec[i] << "\n";
    //}

    //vec.pop_back();

    ////std::cout << "After pop_back, size: " << vec.size() << "\n";

    ////// 使用拷贝构造函数
    ////Vector<int> vecCopy(vec);
    ////std::cout << "Copy Size: " << vecCopy.size() << "\n";

    ////// 使用赋值操作符
    ////Vector<int> vecAssign;
    ////vecAssign = vec;
    ////std::cout << "Assign Size: " << vecAssign.size() << "\n";

    return 0;
}
```

![img](https://cdn.nlark.com/yuque/0/2024/png/45967853/1728970711440-b162a7b0-d2f7-42b7-b7e6-5b7e9df3f689.png)

## oop实现queue

```cpp
#include <iostream>
#include <stdexcept> // for exceptions

template <typename T>
class Queue {
private:
    T* _data;        // 动态分配的数组，保存队列中的元素
    size_t _capacity; // 队列的容量
    size_t _size;     // 队列中的实际元素个数
    size_t _front;    // 指向队列头部元素的索引
    size_t _back;     // 指向队列尾部下一个位置的索引

    // 动态扩容函数
    void resize(size_t newCapacity) {
        T* newData = new T[newCapacity];  // 分配新空间
        // 使用 for 循环手动迁移数据，保持 FIFO 顺序
        for (size_t i = 0; i < _size; ++i) {
            newData[i] = _data[(_front + i) % _capacity];
        }
        delete[] _data;                   // 释放旧空间
        _data = newData;                  // 更新指针
        _capacity = newCapacity;          // 更新容量
        _front = 0;                       // 重置 front 索引
        _back = _size;                    // back 指向新的末尾
    }

public:
    // 默认构造函数
    Queue() : _data(nullptr), _capacity(0), _size(0), _front(0), _back(0) {}

    // 拷贝构造函数
    Queue(const Queue& other) {
        _data = new T[other._capacity];   // 分配与源队列相同的容量
        _capacity = other._capacity;
        _size = other._size;
        _front = 0;
        _back = _size;

        // 使用 for 循环手动复制数据，保持 FIFO 顺序
        for (size_t i = 0; i < _size; ++i) {
            _data[i] = other._data[(other._front + i) % other._capacity];
        }
    }

    // 赋值操作符重载
    Queue& operator=(const Queue& other) {
        if (this != &other) {             // 避免自赋值
            delete[] _data;               // 释放已有的资源

            _data = new T[other._capacity];  // 分配新空间
            _capacity = other._capacity;
            _size = other._size;
            _front = 0;
            _back = _size;

            // 使用 for 循环手动复制数据，保持 FIFO 顺序
            for (size_t i = 0; i < _size; ++i) {
                _data[i] = other._data[(other._front + i) % other._capacity];
            }
        }
        return *this;
    }

    // 析构函数
    ~Queue() {
        delete[] _data;  // 释放动态分配的内存
    }

    // 判断队列是否为空
    bool empty() const {
        return _size == 0;
    }

    // 获取队列中元素的个数
    size_t size() const {
        return _size;
    }

    // 返回队列的前部元素
    T& front() {
        if (empty()) {
            throw std::out_of_range("Queue is empty");
        }
        return _data[_front];
    }

    // 返回队列的前部元素（常量版本）
    const T& front() const {
        if (empty()) {
            throw std::out_of_range("Queue is empty");
        }
        return _data[_front];
    }

    // 返回队列的后部元素
    T& back() {
        if (empty()) {
            throw std::out_of_range("Queue is empty");
        }
        return _data[(_back - 1 + _capacity) % _capacity];
    }

    // 返回队列的后部元素（常量版本）
    const T& back() const {
        if (empty()) {
            throw std::out_of_range("Queue is empty");
        }
        return _data[(_back - 1 + _capacity) % _capacity];
    }

    // 向队列的末尾添加元素
    void push(const T& value) {
        if (_size == _capacity) {
            // 如果容量不足，扩容两倍
            size_t newCapacity = _capacity == 0 ? 1 : _capacity * 2;
            resize(newCapacity);
        }
        _data[_back] = value;            // 将元素添加到队列尾部
        _back = (_back + 1) % _capacity; // 循环使用索引
        ++_size;
    }

    // 移除队列头部元素
    void pop() {
        if (empty()) {
            throw std::out_of_range("Queue is empty");
        }
        _front = (_front + 1) % _capacity; // 移动 front 索引
        --_size;
    }

    // 清空队列
    void clear() {
        _size = 0;
        _front = 0;
        _back = 0;
    }
};

int main() {
    Queue<int> q;
    q.push(1);
    q.push(2);
    q.push(3);

    std::cout << "Front: " << q.front() << std::endl; // 输出: 1
    std::cout << "Back: " << q.back() << std::endl;   // 输出: 3

    q.pop();  // 移除 1

    std::cout << "Front after pop: " << q.front() << std::endl; // 输出: 2

    // 使用拷贝构造函数
    Queue<int> qCopy(q);
    std::cout << "Copy Front: " << qCopy.front() << std::endl; // 输出: 2

    // 使用赋值操作符
    Queue<int> qAssign;
    qAssign = q;
    std::cout << "Assign Front: " << qAssign.front() << std::endl; // 输出: 2

    return 0;
}
```

## 优先级队列，放map（等自定义类型）

```cpp
#include <iostream>  
#include <map>  
#include <queue>  
#include <utility> // for std::pair  
#include <functional> // for std::greater (optional, if you want a min-heap)  

// 假设我们有一个 map，它的键是 int，值是 double  
std::map<int, double> myMap = {{1, 10.5}, {2, 20.3}, {3, 5.7}};  

//或者------------------------------------------
clsaa compareMapPairs {
public:
    bool operator() (const pair<int,int> &a , const pair<int,int> &b) {
        return a.first < b.first;
    }
};
priority_queue< pair<int,int>, vector<pair<int,int>>,compareMapPairs > pq;

//--------------------------------------------------


// 自定义比较器，根据 map 中值的属性来排序（这里直接比较值）  
auto compareMapPairs = [](const std::pair<const int, double>& a, const std::pair<const int, double>& b)
{  
    // 创建一个最大堆（默认行为），基于 map 的值  
    return a.second < b.second; // 注意：这里使用 < 来创建一个最大堆，因为 priority_queue 默认是最大堆  
    // 如果你想要一个最小堆，应该使用 >  
};  

// 定义一个优先队列，使用自定义的比较器  
std::priority_queue<std::pair<const int, double>, std::vector<std::pair<const int, double>>, decltype(compareMapPairs)> pq(compareMapPairs);  

int main() {  
    // 将 map 的元素添加到优先队列中  
    for (const auto& pair : myMap) {  
        pq.push(pair);  
    }  

    // 从优先队列中弹出元素，并打印它们（这里会按照值的降序打印）  
    while (!pq.empty()) {  
        std::cout << "Key: " << pq.top().first << ", Value: " << pq.top().second << std::endl;  
        pq.pop();  
    }  

    return 0;  
}
```

## 运算符重载

因为成员函数时不能实现 30+ complex，但可以complex+30，但全局重载函数都可以实现（要定义为友元函数）！！

```cpp
#include <iostream>

class Complex {
private:
    double real; // 实部
    double imag; // 虚部

public:
    // 默认构造函数
    Complex(double r = 0.0, double i = 0.0) : real(r), imag(i) {}

    // 复数的加法运算符重载
    Complex operator+(const Complex& other) const {
        return Complex(real + other.real, imag + other.imag);
    }

    // 复数的减法运算符重载
    Complex operator-(const Complex& other) const {
        return Complex(real - other.real, imag - other.imag);
    }

    // 复数的乘法运算符重载
    Complex operator*(const Complex& other) const {
        return Complex(real * other.real - imag * other.imag, 
                       real * other.imag + imag * other.real);
    }

    // 复数的除法运算符重载
    Complex operator/(const Complex& other) const {
        double denominator = other.real * other.real + other.imag * other.imag;
        if (denominator == 0) {
            throw std::invalid_argument("Divide by zero error.");
        }
        return Complex((real * other.real + imag * other.imag) / denominator,
                       (imag * other.real - real * other.imag) / denominator);
    }

    // 复数的等号运算符重载
    Complex& operator=(const Complex& other) {
        if (this != &other) {
            real = other.real;
            imag = other.imag;
        }
        return *this;
    }

    // 输出运算符重载，用于打印复数
    friend std::ostream& operator<<(std::ostream& os, const Complex& c) {
        os << c.real;
        if (c.imag >= 0) {
            os << " + " << c.imag << "i";
        } else {
            os << " - " << -c.imag << "i";
        }
        return os;
    }

    // 输入运算符重载，用于输入复数
    friend std::istream& operator>>(std::istream& is, Complex& c) {
        std::cout << "Enter real part: ";
        is >> c.real;
        std::cout << "Enter imaginary part: ";
        is >> c.imag;
        return is;
    }
};

int main() {
    Complex c1, c2;
    
    std::cout << "Enter first complex number:\n";
    std::cin >> c1;
    
    std::cout << "Enter second complex number:\n";
    std::cin >> c2;

    std::cout << "c1 = " << c1 << std::endl;
    std::cout << "c2 = " << c2 << std::endl;

    Complex sum = c1 + c2;
    std::cout << "c1 + c2 = " << sum << std::endl;

    Complex diff = c1 - c2;
    std::cout << "c1 - c2 = " << diff << std::endl;

    Complex prod = c1 * c2;
    std::cout << "c1 * c2 = " << prod << std::endl;

    try {
        Complex div = c1 / c2;
        std::cout << "c1 / c2 = " << div << std::endl;
    } catch (const std::invalid_argument& e) {
        std::cout << e.what() << std::endl;
    }

    return 0;
}
#include <iostream>

class Complex {
private:
    double real; // 实部
    double imag; // 虚部

public:
    // 默认构造函数
    Complex(double r = 0.0, double i = 0.0) : real(r), imag(i) {}

    // 访问实部和虚部
    double getReal() const { return real; }
    double getImag() const { return imag; }

    // 设置实部和虚部
    void setReal(double r) { real = r; }
    void setImag(double i) { imag = i; }

    // 输出运算符重载，用于打印复数
    friend std::ostream& operator<<(std::ostream& os, const Complex& c);
    
    // 输入运算符重载，用于输入复数
    friend std::istream& operator>>(std::istream& is, Complex& c);
};

// 全局加法运算符重载
Complex operator+(const Complex& c1, const Complex& c2) {
    return Complex(c1.getReal() + c2.getReal(), c1.getImag() + c2.getImag());
}

// 全局减法运算符重载
Complex operator-(const Complex& c1, const Complex& c2) {
    return Complex(c1.getReal() - c2.getReal(), c1.getImag() - c2.getImag());
}

// 全局乘法运算符重载
Complex operator*(const Complex& c1, const Complex& c2) {
    return Complex(c1.getReal() * c2.getReal() - c1.getImag() * c2.getImag(),
                   c1.getReal() * c2.getImag() + c1.getImag() * c2.getReal());
}

// 全局除法运算符重载
Complex operator/(const Complex& c1, const Complex& c2) {
    double denominator = c2.getReal() * c2.getReal() + c2.getImag() * c2.getImag();
    if (denominator == 0) {
        throw std::invalid_argument("Divide by zero error.");
    }
    return Complex((c1.getReal() * c2.getReal() + c1.getImag() * c2.getImag()) / denominator,
                   (c1.getImag() * c2.getReal() - c1.getReal() * c2.getImag()) / denominator);
}

// 输出运算符重载
std::ostream& operator<<(std::ostream& os, const Complex& c) {
    os << c.real;
    if (c.imag >= 0) {
        os << " + " << c.imag << "i";
    } else {
        os << " - " << -c.imag << "i";
    }
    return os;
}

// 输入运算符重载
std::istream& operator>>(std::istream& is, Complex& c) {
    std::cout << "Enter real part: ";
    is >> c.real;
    std::cout << "Enter imaginary part: ";
    is >> c.imag;
    return is;
}

int main() {
    Complex c1, c2;

    std::cout << "Enter first complex number:\n";
    std::cin >> c1;

    std::cout << "Enter second complex number:\n";
    std::cin >> c2;

    std::cout << "c1 = " << c1 << std::endl;
    std::cout << "c2 = " << c2 << std::endl;

    Complex sum = c1 + c2;
    std::cout << "c1 + c2 = " << sum << std::endl;

    Complex diff = c1 - c2;
    std::cout << "c1 - c2 = " << diff << std::endl;

    Complex prod = c1 * c2;
    std::cout << "c1 * c2 = " << prod << std::endl;

    try {
        Complex div = c1 / c2;
        std::cout << "c1 / c2 = " << div << std::endl;
    } catch (const std::invalid_argument& e) {
        std::cout << e.what() << std::endl;
    }

    return 0;
}
complex operator++(int)
{
    return complex(mreal++,mimage++);
}

complex& operator++()
{
    mreal+=1;
    mimage+=1;
    return *this;
}
// 输出运算符重载
std::ostream& operator<<(std::ostream& os, const Complex& c) {
    os << c.real;
    if (c.imag >= 0) {
        os << " + " << c.imag << "i";
    } else {
        os << " - " << -c.imag << "i";
    }
    return os;
}

// 输入运算符重载
std::istream& operator>>(std::istream& is, Complex& c) {
    std::cout << "Enter real part: ";
    is >> c.real;
    std::cout << "Enter imaginary part: ";
    is >> c.imag;
    return is;
}
#include <iostream>
#include <cstring>  // for strlen, strcpy, etc.

class MyString {
private:
    char* data;    // 指向字符串数据的指针
    size_t length; // 字符串的长度

public:
    // 嵌套的迭代器类
    class Iterator {
    private:
        char* ptr; // 指向当前字符的指针
    public:
        // 构造函数
        Iterator(char* p) : ptr(p) {}

        // 重载解引用运算符，返回当前字符
        char& operator*() const {
            return *ptr;
        }

        // 重载前置++运算符，移动到下一个字符
        Iterator& operator++() {
            ++ptr;
            return *this;
        }

        // 重载后置++运算符，移动到下一个字符
        Iterator operator++(int) {
            Iterator temp = *this;
            ++ptr;
            return temp;
        }

        // 重载相等运算符
        bool operator==(const Iterator& other) const {
            return ptr == other.ptr;
        }

        // 重载不相等运算符
        bool operator!=(const Iterator& other) const {
            return ptr != other.ptr;
        }
    };

    // 默认构造函数
    MyString() : data(nullptr), length(0) {
        data = new char[1];
        data[0] = '\0';
    }

    // 通过 C 风格字符串构造 MyString
    MyString(const char* str) {
        length = std::strlen(str);
        data = new char[length + 1];
        std::strcpy(data, str);
    }

    // 拷贝构造函数
    MyString(const MyString& other) {
        length = other.length;
        data = new char[length + 1];
        std::strcpy(data, other.data);
    }

    // 移动构造函数
    MyString(MyString&& other) noexcept {
        data = other.data;
        length = other.length;
        other.data = nullptr;
        other.length = 0;
    }

    // 赋值运算符重载（深拷贝）
    MyString& operator=(const MyString& other) {
        if (this != &other) {
            delete[] data;  // 释放旧数据

            length = other.length;
            data = new char[length + 1];
            std::strcpy(data, other.data);
        }
        return *this;
    }

    // 移动赋值运算符
    MyString& operator=(MyString&& other) noexcept {
        if (this != &other) {
            delete[] data;  // 释放旧数据

            data = other.data;
            length = other.length;

            other.data = nullptr;
            other.length = 0;
        }
        return *this;
    }

    // 析构函数
    ~MyString() {
        delete[] data;
    }

    // 获取字符串长度
    size_t size() const {
        return length;
    }

    // 获取 C 风格字符串
    const char* c_str() const {
        return data;
    }

    // begin() 函数，返回指向字符串开头的迭代器
    Iterator begin() {
        return Iterator(data);
    }

    // end() 函数，返回指向字符串末尾（\0）的迭代器
    Iterator end() {
        return Iterator(data + length);
    }

    // 输出运算符重载
    friend std::ostream& operator<<(std::ostream& os, const MyString& str) {
        os << str.data;
        return os;
    }

    // 输入运算符重载
    friend std::istream& operator>>(std::istream& is, MyString& str) {
        char buffer[1024];
        is >> buffer;
        str = MyString(buffer);  // 使用赋值运算符
        return is;
    }
};

int main() {
    MyString str("Hello, World!");

    // 使用迭代器遍历字符串
    for (MyString::Iterator it = str.begin(); it != str.end(); ++it) {
        std::cout << *it << " ";
    }
    std::cout << std::endl;

    return 0;
}
#include <iostream>

// 定义 Pool 的项数量
#define POOL_ITEM_SIZE 10

template <typename T>
class QueueItem {
public:
    T _data;               // 队列节点的数据
    QueueItem* _next;      // 指向下一个节点的指针

    // 静态变量，用于对象池的管理
    static QueueItem* _itemPool;

    // 重载 new 运算符，从对象池中分配内存
    static void* operator new(size_t size) {
        // 如果对象池为空，初始化对象池
        if (_itemPool == nullptr) {
            // 分配一块连续的内存
            _itemPool = (QueueItem*)new char[POOL_ITEM_SIZE * sizeof(QueueItem)];

            // 将分配的内存块链接成一个链表，放入对象池
            QueueItem* p = _itemPool;
            for (size_t i = 0; i < POOL_ITEM_SIZE - 1; ++i) {
                p->_next = p + 1; // 指向下一个节点
                p++;
            }
            p->_next = nullptr; // 最后一个节点的 next 指针为 nullptr
        }

        // 从对象池中取出一个节点
        QueueItem* p = _itemPool;
        _itemPool = _itemPool->_next; // 更新对象池的头部
        return p;
    }

    // 重载 delete 运算符，将内存归还到对象池
    static void operator delete(void* ptr) {
        // 将释放的对象放回到对象池
        QueueItem* p = static_cast<QueueItem*>(ptr);
        p->_next = _itemPool;
        _itemPool = p;
    }
};

// 初始化静态变量
template <typename T>
QueueItem<T>* QueueItem<T>::_itemPool = nullptr;

// 链式队列类
template <typename T>
class Queue {
private:
    QueueItem<T>* front; // 指向队列头部
    QueueItem<T>* rear;  // 指向队列尾部

public:
    // 构造函数，初始化空队列
    Queue() : front(nullptr), rear(nullptr) {}

    // 入队操作，插入数据到队列尾部
    void enqueue(const T& value) {
        QueueItem<T>* node = new QueueItem<T>(); // 从对象池分配新节点
        node->_data = value;
        node->_next = nullptr;

        if (rear == nullptr) {
            front = rear = node;
        } else {
            rear->_next = node;
            rear = node;
        }
    }

    // 出队操作，移除队列头部的元素
    T dequeue() {
        if (front == nullptr) {
            throw std::out_of_range("Queue is empty");
        }

        QueueItem<T>* temp = front;
        T value = temp->_data;
        front = front->_next;

        if (front == nullptr) {
            rear = nullptr;
        }

        delete temp; // 归还节点到对象池
        return value;
    }

    // 检查队列是否为空
    bool isEmpty() const {
        return front == nullptr;
    }

    // 析构函数，销毁队列并释放所有节点
    ~Queue() {
        while (!isEmpty()) {
            dequeue();
        }
    }
};

int main() {
    Queue<int> queue;

    // 入队测试
    queue.enqueue(1);
    queue.enqueue(2);
    queue.enqueue(3);

    // 出队测试
    while (!queue.isEmpty()) {
        std::cout << "Dequeued: " << queue.dequeue() << std::endl;
    }

    return 0;
}
```

这行代码实际上做了以下几件事：

- **第一参数** `**ObjectPoolItem\***`：它是指向 `ObjectPoolItem` 的原始指针，也就是 `std::unique_ptr` 将要管理的对象。
- **第二参数** `**ObjectPoolDeleter**`：`std::unique_ptr` 的第二个模板参数定义了一个自定义的删除器。这个删除器默认是通过它的默认构造函数来创建的。
- ！！！！！！！！！！！！自定义删除器第二个传入的是类型类型类型类型！！！！！！！！！！！
- 用类名可以是因为类名就代表一个类型，函数需要用decltype（&函数名）出其类型void（*）（int）

`ObjectPoolDeleter` 是一个类型，在 `std::unique_ptr` 构造时，C++ 会自动使用 `ObjectPoolDeleter` 的默认构造函数（即 `ObjectPoolDeleter()`) 来创建删除器对象。

```cpp
// 自定义删除器，使用对象池的 delete 运算符
struct ObjectPoolDeleter {
    void operator()(ObjectPoolItem* p) const {
        delete p; // 调用对象池的 delete
    }
};

int main() {
    // 使用 std::unique_ptr，并传入自定义删除器
    std::unique_ptr<ObjectPoolItem, ObjectPoolDeleter> item1(new ObjectPoolItem);
    item1->data = 100;
    std::cout << "Item1 Data: " << item1->data << std::endl;
```

在 C++ 中，自定义删除器可以是一个函数、函数对象（如 `struct` 或 `class`）、或者类的成员函数。标准库中的智能指针（如 `std::unique_ptr` 和 `std::shared_ptr`）支持这些不同类型的删除器。

### 1. 使用普通函数作为自定义删除器

你可以将一个普通的全局函数作为 `std::unique_ptr` 的删除器，传递给智能指针。

#### 示例：使用全局函数作为删除器

```cpp
#include <iostream>
#include <memory>

// 定义一个普通函数作为删除器
void customDeleter(int* ptr) {
    std::cout << "Custom delete function called. Deleting int pointer." << std::endl;
    delete ptr;
}

int main() {
    // 创建一个 std::unique_ptr，使用普通函数作为删除器
    std::unique_ptr<int, decltype(&customDeleter)> p(new int(42), customDeleter);

    std::cout << "Value: " << *p << std::endl;

    // 智能指针超出作用域时调用 customDeleter 函数
    return 0;
}
```

#### 说明：

- `decltype(&customDeleter)` 用来获取 `customDeleter` 函数的类型，以作为 `std::unique_ptr` 的删除器类型。
- 当智能指针 `p` 超出作用域时，它会自动调用 `customDeleter` 来释放内存。

### 2. 使用 `struct` 或 `class` 函数对象作为删除器

自定义删除器也可以是一个函数对象（`functor`），它是一个带有 `operator()` 的类或结构体。这样可以通过成员变量来存储删除时需要的额外信息。

#### 示例：使用 `struct` 作为删除器

```cpp
#include <iostream>
#include <memory>

// 自定义删除器结构体
struct CustomDeleter {
void operator()(int* ptr) const {
    std::cout << "CustomDeleter struct called. Deleting int pointer." << std::endl;
    delete ptr;
}
};

int main() {
    // 使用自定义删除器（函数对象）创建 std::unique_ptr
    std::unique_ptr<int, CustomDeleter> p(new int(42));

    std::cout << "Value: " << *p << std::endl;

    // 智能指针超出作用域时调用 CustomDeleter::operator()
    return 0;
}
```

#### 说明：

- `CustomDeleter` 定义了一个 `operator()`，这使得它可以像函数一样被调用。
- 当 `std::unique_ptr` 的对象超出作用域时，会自动调用 `CustomDeleter` 的 `operator()`，从而释放内存。

### 3. 使用类的成员函数作为删除器

如果你希望在某个类中定义一个成员函数作为删除器，你可以使用 `std::bind` 或 Lambda 表达式将该成员函数绑定到智能指针中。

#### 示例：使用成员函数作为删除器

```cpp
#include <iostream>
#include <memory>
#include <functional>  // For std::bind

// 类定义
class MyClass {
    public:
    // 成员函数作为自定义删除器
    void customDelete(int* ptr) const {
        std::cout << "MyClass::customDelete called. Deleting int pointer." << std::endl;
        delete ptr;
    }
};

int main() {
    MyClass obj;

    // 使用 std::bind 将成员函数绑定到智能指针
    std::unique_ptr<int, std::function<void(int*)>> p(new int(42), 
    std::bind(&MyClass::customDelete, &obj, std::placeholders::_1));

    std::cout << "Value: " << *p << std::endl;

    // 智能指针超出作用域时，调用 MyClass::customDelete 释放内存
    return 0;
}
```

#### 说明：

- `std::bind` 用于绑定成员函数 `MyClass::customDelete` 到 `std::unique_ptr` 的删除器中。
- `std::placeholders::_1` 用来占位表示传递给删除器的参数，也就是智能指针管理的 `int*` 指针。
- 通过这种方式，当智能指针超出作用域时，会调用类的成员函数来释放内存。

### 4. 使用 Lambda 表达式作为删除器

C++11 引入了 Lambda 表达式，使用 Lambda 作为删除器更加简洁，尤其是在类的成员函数的场景下。

#### 示例：使用 Lambda 表达式作为删除器

```cpp
#include <iostream>
#include <memory>

int main() {
    // 使用 Lambda 表达式作为自定义删除器
    auto deleter = [](int* ptr) {
        std::cout << "Lambda deleter called. Deleting int pointer." << std::endl;
        delete ptr;
    };

    std::unique_ptr<int, decltype(deleter)> p(new int(42), deleter);

    std::cout << "Value: " << *p << std::endl;

    // 智能指针超出作用域时调用 Lambda 表达式
    return 0;
}
```

#### 说明：

- Lambda 表达式可以非常灵活地定义删除器，特别适合需要局部状态或简单逻辑的场景。
- `decltype(deleter)` 用于推导 Lambda 表达式的类型，传递给 `std::unique_ptr`。

### 总结：

1. **普通函数**：可以直接将函数指针作为删除器传递给智能指针。
2. **函数对象（**`**struct**` **或** `**class**`**）**：通过定义 `operator()`，可以将类对象作为删除器，适合需要携带状态的删除器。
3. **成员函数**：通过 `std::bind` 或 Lambda 表达式，可以将类的成员函数作为删除器。
4. **Lambda 表达式**：提供了一种简洁的方式定义自定义删除器，适合简单的场景。

这些方法都可以用来扩展智能指针的删除行为，实现对对象的灵活控制和内存管理。

##### 您说：

为什么用decltype(deleter)

###### ChatGPT 说：

在 C++ 中，`decltype` 是一种用于推导表达式类型的关键字。当我们使用 Lambda 表达式或函数指针作为删除器时，我们需要为智能指针提供删除器的类型。由于 Lambda 表达式的类型是由编译器自动生成的（而不是标准的函数类型或类类型），我们无法直接手动指定它的类型。因此，`decltype` 关键字可以帮助我们获取该 Lambda 表达式的确切类型。

### 问题背景

当你使用智能指针（如 `std::unique_ptr`）并传递自定义删除器时，智能指针的模板参数中需要指定删除器的类型。Lambda 表达式是匿名的，它们的类型不是显式的函数类型，也不像普通的 `struct` 或 `class` 那样容易手动指定类型。

例如：

```cpp
auto deleter = [](int* ptr) {
    std::cout << "Lambda deleter called. Deleting int pointer." << std::endl;
    delete ptr;
};
```

这个 `deleter` 是一个 Lambda 表达式，它的类型是编译器生成的匿名类型。为了将它传递给 `std::unique_ptr`，我们需要获取这个匿名类型。

### 为什么使用 `decltype`？

`decltype` 关键字用于推导表达式的类型。通过 `decltype(deleter)`，我们可以获取这个 Lambda 表达式的类型，并将其作为 `std::unique_ptr` 的删除器类型。

例如：

```cpp
std::unique_ptr<int, decltype(deleter)> p(new int(42), deleter);
```

这里我们通过 `decltype(deleter)` 来指定 `std::unique_ptr` 的第二个模板参数，也就是删除器的类型。

### 详细解释：

1. **Lambda 表达式的类型是匿名的**：Lambda 表达式没有普通的函数类型，而是由编译器生成一个匿名类，它重载了 `operator()` 来实现函数调用。你无法在代码中直接写出 Lambda 的类型。

- - 例如，`auto deleter = [](int* ptr) { /* ... */ };` 这个 Lambda 表达式的实际类型类似于一个内部的类类型，带有一个 `operator()`。

1. **decltype 获取类型**：使用 `decltype(deleter)` 可以告诉编译器推导 `deleter` 的类型，并且作为 `std::unique_ptr` 的模板参数。

- - `decltype(deleter)` 会返回该 Lambda 表达式的类型，这样我们就可以在 `std::unique_ptr<int, decltype(deleter)>` 中正确使用它。

### 代码示例

```cpp
#include <iostream>
#include <memory>

int main() {
    // 定义一个 Lambda 表达式作为删除器
    auto deleter = [](int* ptr) {
        std::cout << "Lambda deleter called. Deleting int pointer." << std::endl;
        delete ptr;
    };

    // 使用 decltype 获取 Lambda 表达式的类型，并传递给 std::unique_ptr
    std::unique_ptr<int, decltype(deleter)> p(new int(42), deleter);

    std::cout << "Value: " << *p << std::endl;

    // 当 p 超出作用域时，自动调用 Lambda 删除器
    return 0;
}
```

#### 解释：

1. **Lambda 删除器**：`deleter` 是一个 Lambda 表达式，它接收一个 `int*` 类型的参数并删除它。
2. **decltype(deleter)**：我们使用 `decltype(deleter)` 来推导这个 Lambda 表达式的类型，并将其作为 `std::unique_ptr` 的第二个模板参数。
3. **智能指针管理对象**：`std::unique_ptr<int, decltype(deleter)> p(new int(42), deleter);` 创建了一个智能指针，它管理一个 `int` 对象，并且使用 Lambda 表达式作为自定义删除器。

### 如果不用 `decltype` 会怎样？

如果我们不用 `decltype`，则无法直接写出 Lambda 表达式的类型，因为 Lambda 是编译器生成的匿名类型。只有通过 `decltype` 我们才能正确推导出 Lambda 表达式的类型，并将其作为模板参数传递。

### 总结：

- **Lambda 表达式的类型是匿名的**，无法通过手动指定类型，因此我们需要使用 `decltype` 来推导出它的类型。
- `**decltype(deleter)**` 用于推导出 `deleter`（Lambda 表达式）的确切类型，并将其作为 `std::unique_ptr` 的模板参数。
- `decltype` 关键字非常有用，特别是在处理复杂类型（如 Lambda 或其他模板类型）时，它可以自动推导出变量的类型并在模板中使用。

##### 您说：

decltype(&customDeleter) 用来获取 customDeleter 函数的类型这里为什么也要？

###### ChatGPT 说：

在 C++ 中，函数指针也是一种类型，当我们将普通函数作为自定义删除器传递给 `std::unique_ptr` 时，需要为 `std::unique_ptr` 明确指定删除器的类型。而 `decltype(&customDeleter)` 可以用于推导该函数指针的类型。

### 问题背景

当我们使用函数作为自定义删除器时，需要告诉 `std::unique_ptr` 删除器的类型。删除器可以是：

- 函数指针类型
- Lambda 表达式（其类型为匿名类）
- 函数对象（`struct` 或 `class`）

**函数指针** 的类型与函数本身的签名（参数类型、返回类型）有关。直接使用 `decltype(&customDeleter)` 可以明确表示删除器的类型是指向 `customDeleter` 函数的指针类型，这对于智能指针模板的正确类型推导是必要的。

### 为什么要用 `decltype(&customDeleter)`？

- **函数指针类型的推导**：`customDeleter` 是一个函数，它的类型是 `void(*)(int*)`，这是一个函数指针类型。我们需要明确指定 `std::unique_ptr` 的删除器类型为这个函数指针。
- `**decltype(&customDeleter)**` **的作用**：`decltype(&customDeleter)` 用来获取函数指针的类型。如果我们直接写 `customDeleter`，则编译器并不会明确它是一个指针类型。通过 `&` 符号获取函数指针，再通过 `decltype` 推导出该指针类型，这样智能指针就知道删除器的确切类型。

### 代码示例：使用普通函数作为删除器

```cpp
#include <iostream>
#include <memory>

// 定义一个普通函数作为删除器
void customDeleter(int* ptr) {
    std::cout << "Custom delete function called. Deleting int pointer." << std::endl;
    delete ptr;
}

int main() {
    // 使用普通函数 customDeleter 作为删除器
    // 通过 decltype(&customDeleter) 来指定函数指针类型
    std::unique_ptr<int, decltype(&customDeleter)> p(new int(42), &customDeleter);

    std::cout << "Value: " << *p << std::endl;

    // 智能指针超出作用域时调用 customDeleter 函数释放内存
    return 0;
}
```

#### 解释：

1. `**customDeleter**`：这是一个普通的全局函数，删除 `int*` 类型的指针。
2. `**decltype(&customDeleter)**`：我们使用 `decltype(&customDeleter)` 来推导出函数指针的类型。`&customDeleter` 是指向 `customDeleter` 函数的指针，它的类型为 `void(*)(int*)`。
3. **传递给** `**std::unique_ptr**`：我们将 `&customDeleter` 作为删除器传递给 `std::unique_ptr`，并通过 `decltype(&customDeleter)` 明确删除器的类型。

### 如果不使用 `decltype` 会怎么样？

如果你不使用 `decltype(&customDeleter)` 明确指定函数指针的类型，那么你必须手动为 `std::unique_ptr` 提供正确的删除器类型。你可以直接写出函数指针类型，但对于复杂的函数签名来说，这可能变得非常繁琐。

例如，你可以手动指定 `std::unique_ptr<int, void(*)(int*)>` 来替代 `decltype(&customDeleter)`，但这样不够灵活，尤其当函数签名复杂时，手动指定类型可能容易出错。

```cpp
// 手动指定函数指针类型，但不够灵活
std::unique_ptr<int, void(*)(int*)> p(new int(42), &customDeleter);
```

### `decltype(&customDeleter)` 的优势

1. **自动推导类型**：`decltype(&customDeleter)` 可以自动推导出函数指针的类型，无需手动指定。当删除器函数的签名复杂时，`decltype` 能确保正确推导出类型，避免手动出错。
2. **简化代码**：当我们传递不同的函数作为删除器时，使用 `decltype` 可以简化代码，让代码更加简洁灵活。例如，多个不同签名的删除器函数可以通过 `decltype` 轻松推导出类型。

### 总结：

- `**decltype(&customDeleter)**` **用来推导函数指针类型**，因为 `customDeleter` 是一个函数，而不是函数指针，`decltype` 帮助获取其函数指针的类型。
- **函数指针的类型是** `**void(\*)(int\*)**`，而不是 `void(int*)`。使用 `decltype(&customDeleter)` 可以简洁地获取这个指针类型，减少手动写出复杂类型的风险。
- **灵活性**：使用 `decltype` 可以自动推导函数指针的类型，这对于通用代码的编写更加方便。

## top-K问题，自定义priority_queue

```cpp
class compare
    {
    public:
        bool operator()(pair<int,int>&a,pair<int,int>&b)
        {
            return a.second < b.second;  //表示小的在下面，大的值在堆顶，为大根堆
        }
    };

    vector<int> topKFrequent(vector<int>& nums, int k) {
        int n = nums.size()-1;
        unordered_map<int,int> cnt;
        for(int i = 0;i<=n;i++)
        {
            cnt[nums[i]]++;
        }
        priority_queue< pair<int,int> , vector<pair<int,int>>,compare> que;
        for(auto &m : cnt)
        {
            que.push(m);
        }
        vector<int> res(k);
        for(int i = 0;i<k;i++)
        {
            //res.push_back(que.top().first);
            res[i] = que.top().first;
            que.pop();
        }
        return res;
```

## 回溯算法模版

```plain
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
```

## 排序算法

```cpp
排序算法比较与核心代码实现
排序算法是计算机科学中最基础且重要的算法之一，不同的排序算法适用于不同的场景，具有不同的时间复杂度、空间复杂度和稳定性。下面我将介绍几种常见的排序算法，并比较它们的优缺点，同时给出核心代码实现。

1. 常见排序算法比较
排序算法	平均时间复杂度	最坏时间复杂度	空间复杂度	稳定性	适用场景
冒泡排序	O(n²)	O(n²)	O(1)	稳定	小规模数据或基本有序数据
选择排序	O(n²)	O(n²)	O(1)	不稳定	小规模数据
插入排序	O(n²)	O(n²)	O(1)	稳定	小规模或部分有序数据
希尔排序	O(n log n)	O(n²)	O(1)	不稳定	中等规模数据
归并排序	O(n log n)	O(n log n)	O(n)	稳定	大规模数据，需要稳定排序
快速排序	O(n log n)	O(n²)	O(log n)	不稳定	大规模数据，平均性能最好
堆排序	O(n log n)	O(n log n)	O(1)	不稳定	大规模数据，内存受限
计数排序	O(n + k)	O(n + k)	O(n + k)	稳定	数据范围较小（如0~100）
桶排序	O(n + k)	O(n²)	O(n + k)	稳定	数据均匀分布
基数排序	O(n × k)	O(n × k)	O(n + k)	稳定	非负整数排序
说明：

稳定性：排序后相同元素的相对顺序是否保持不变。
时间复杂度：衡量算法执行时间随输入规模增长的变化趋势。
空间复杂度：衡量算法额外使用的内存空间。
2. 核心代码实现
(1) 冒泡排序（Bubble Sort）
原理：重复遍历数组，比较相邻元素，如果顺序错误就交换，直到没有交换发生。

void bubbleSort(int arr[], int n) {
    for (int i = 0; i < n - 1; i++) {
        bool swapped = false;
        for (int j = 0; j < n - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                swap(arr[j], arr[j + 1]);
                swapped = true;
            }
        }
        if (!swapped) break; // 提前终止
    }   
}
(2) 选择排序（Selection Sort）
原理：每次从未排序部分选择最小（或最大）元素，放到已排序部分的末尾。

void selectionSort(int arr[], int n) {
    for (int i = 0; i < n - 1; i++) {
        int minIdx = i;
        for (int j = i + 1; j < n; j++) {
            if (arr[j] < arr[minIdx]) {
                minIdx = j;
            }
        }
        swap(arr[i], arr[minIdx]);
    }
}
(3) 插入排序（Insertion Sort）
原理：将未排序部分的元素逐个插入到已排序部分的正确位置。

void insertionSort(int arr[], int n) {
    for (int i = 1; i < n; i++) {
        int key = arr[i];
        int j = i - 1;
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];
            j--;
        }
        arr[j + 1] = key;
    }
}
(4) 快速排序（Quick Sort）
原理：分治法，选择一个基准（pivot），将数组分成两部分，左边小于基准，右边大于基准，递归排序。

int partition(int arr[], int low, int high) {
    int pivot = arr[high];
    int i = low - 1;
    for (int j = low; j < high; j++) {
        if (arr[j] < pivot) {
            i++;
            swap(arr[i], arr[j]);
        }
    }
    swap(arr[i + 1], arr[high]);
    return i + 1;   
}
   
void quickSort(int arr[], int low, int high) {
    if (low < high) {
        int pi = partition(arr, low, high);
        quickSort(arr, low, pi - 1);
        quickSort(arr, pi + 1, high);
    }
}
(5) 归并排序（Merge Sort）
原理：分治法，递归地将数组分成两半，分别排序后合并。

void merge(int arr[], int l, int m, int r) {
    int n1 = m - l + 1, n2 = r - m;
    int L[n1], R[n2];
    for (int i = 0; i < n1; i++) L[i] = arr[l + i];
    for (int j = 0; j < n2; j++) R[j] = arr[m + 1 + j];
    int i = 0, j = 0, k = l;
    while (i < n1 && j < n2) {
        if (L[i] <= R[j]) arr[k++] = L[i++];
        else arr[k++] = R[j++];
    }
    while (i < n1) arr[k++] = L[i++];
    while (j < n2) arr[k++] = R[j++];   
}
   
void mergeSort(int arr[], int l, int r) {
    if (l < r) {
        int m = l + (r - l) / 2;
        mergeSort(arr, l, m);
        mergeSort(arr, m + 1, r);
        merge(arr, l, m, r);
    }
}
(6) 堆排序（Heap Sort）
原理：利用堆数据结构（大顶堆或小顶堆）进行排序。

void heapify(int arr[], int n, int i) {
    int largest = i;
    int left = 2 * i + 1, right = 2 * i + 2;
    if (left < n && arr[left] > arr[largest]) largest = left;
    if (right < n && arr[right] > arr[largest]) largest = right;
    if (largest != i) {
        swap(arr[i], arr[largest]);
        heapify(arr, n, largest);
    }   
}
   
void heapSort(int arr[], int n) {
    for (int i = n / 2 - 1; i >= 0; i--) heapify(arr, n, i);
    for (int i = n - 1; i > 0; i--) {
        swap(arr[0], arr[i]);
        heapify(arr, i, 0);
    }
}
3. 如何选择合适的排序算法？
小规模数据（n < 100）：插入排序、冒泡排序、选择排序（简单且稳定）。
中等规模数据（100 < n < 1000）：希尔排序（优化插入排序）。
大规模数据（n > 1000）：
需要稳定排序 → 归并排序。
内存受限 → 堆排序。
平均性能最好 → 快速排序（但最坏情况 O(n²)）。
特殊数据：
数据范围小（如0~100） → 计数排序、桶排序。
非负整数排序 → 基数排序。
4. 总结
时间复杂度最低：归并排序、快速排序、堆排序（O(n log n)）。
空间复杂度最低：冒泡排序、选择排序、插入排序、希尔排序、堆排序（O(1)）。
稳定排序：冒泡排序、插入排序、归并排序、计数排序、桶排序、基数排序。
希望这些排序算法的比较和代码实现能帮助你更好地理解它们的适用场景和优化方式！如果有具体需求，可以进一步讨论最优选择。
void quickSort(vector<int>& a, int low, int high) {
	if (low >= high)		// 结束标志
		return;
	int first = low;		// 低位下标
	int last = high;		// 高位下标
	int key = a[first];		// 设第一个为基准

	while (first < last)
	{
		// 从后往前走，将比第一个小的移到前面
		while (first < last && a[last] > key)
			last--;
		if (first < last)
			a[first++] = a[last];

		//从前往后走， 将比第一个大的移到后面
		while (first < last && a[first] <= key)
			first++;
		if (first < last)
			a[last--] = a[first];
	}

	a[first] = key;
	// 前半递归
	quickSort(a, low, first - 1);
	// 后半递归
	quickSort(a, first + 1, high);
	
}


quickSort(A, 0,A.size()-1);
	for (auto a : A) {
		cout << a << endl;
	}
void mergeSortCore(vector<int>& data, vector<int>& dataTemp, int low, int high) {

	if (low >= high) return;
	int len = high - low, mid = low + len / 2;
	int start1 = low, end1 = mid, start2 = mid + 1, end2 = high;
	mergeSortCore(data, dataTemp, start1, end1);
	mergeSortCore(data, dataTemp, start2, end2);
	int index = low;
	while (start1 <= end1 && start2 <= end2) {
		dataTemp[index++] = data[start1] < data[start2] ? data[start1++] : data[start2++];
	}

	while (start1 <= end1) {
		dataTemp[index++] = data[start1++];
	}


	while (start2 <= end2) {
		dataTemp[index++] = data[start2++];
	}

	for (index = low; index <= high; ++index) {
		data[index] = dataTemp[index];
	}
}


void mergeSort(vector<int>& data) {
	int len = data.size();
	vector<int> dataTemp(len, 0);
	mergeSortCore(data, dataTemp, 0, len - 1);
}
```

## 二分法模板

low<=high, low=mid+1,high=mid-1;

```cpp
int searchRightmost(vector<int>& nums, int target) {
    int left = 0, right = (int) nums.size() - 1; // 闭区间 [left, right]
    
    while (left <= right) { // 区间不为空
        int mid = left + (right - left) / 2;
        
        if (nums[mid] <= target) {
            left = mid + 1; // 范围缩小到 [mid+1, right]，继续向右查找
        } else {
            right = mid - 1; // 范围缩小到 [left, mid-1]
        }
    }
    
    // 返回 right，因为当循环结束时，right 会指向最右边的目标值
    if (right >= 0 && nums[right] == target) {
        return right; // right 指向最右边的目标值
    }
    return -1; // 未找到目标值
}
 int left = 0, right = (int) nums.size() - 1; // 闭区间 [left, right]
        while (left <= right) { // 区间不为空
            // 循环不变量：
            // nums[left-1] < target
            // nums[right+1] >= target
            int mid = left + (right - left) / 2;
            if (nums[mid] < target) {
                left = mid + 1; // 范围缩小到 [mid+1, right]
            } else {
                right = mid - 1; // 范围缩小到 [left, mid-1]
            }
        }
        return left;
按照这个写法，
```

## 升序合并k个链表

```cpp
class Solution {
public:
    ListNode* mergeKLists(vector<ListNode*>& lists) {
       function<bool(ListNode*,ListNode*)> cmp =
        [](ListNode* a,ListNode* b) -> bool {return a->val > b->val;} ;
        //std::function<bool(ListNode*, ListNode*)> cmp = 
        //[](ListNode* a, ListNode* b) -> bool {return a->val > b->val;};
        priority_queue<ListNode*,vector<ListNode*>,decltype(cmp)> pq(cmp);
        for(auto head: lists)
        {  
            if(head)
            {
                pq.push(head);
            }
        }
        ListNode* pre=new ListNode(0,nullptr);
        auto cur = pre;
        while(!pq.empty())
        {
            auto node = pq.top();
            pq.pop();
            if(node->next)
            {
                pq.push(node->next);
            }
            cur->next=node;
            cur=cur->next;
        }
        return pre->next;

    }
};
```

## bitset

```cpp
#include <iostream>   
#include <bitset>  // 包含位图容器头文件   
#include <cstdlib> // 包含 rand() 和 srand()   
#include <ctime>   // 包含 time() 用于生成随机种子   
using namespace std;
   
int main()   
{
    // 内存问题：bitset大小必须是编译期常量，此处会导致编译错误
    const int size = 100000000; // 声明1亿位的位图（实际需要约12MB内存）
    bitset<size> *b = new bitset<size>; // 错误用法：堆分配无法解决bitset的编译期大小限制

    (*b).reset(); // 初始化所有位为0
    cout << (*b).size() << endl; // 输出位图容量（应显示100000000）

    // 设置随机种子
    srand(time(0)); // 使用当前时间作为随机种子

    // 随机生成10000个8位数字的电话号码
    for (int i = 0; i < 10000; i++)
    {
        int num = 10000000 + rand() % 90000000; // 生成8位随机数
        (*b)[num] = 1; // 设置对应位为1
    }

    // 遍历效率问题：1亿次循环效率极低
    for (int i = 0; i < size; i++)
    {
        if ((*b)[i] == 1)
            cout << "电话号码是：" << i << endl; // 输出存在的号码
    }

    delete b; // 释放内存
    system("pause"); // 暂停程序   
}
#include <iostream>
#include <unordered_map>
#include <string>

using namespace std;

class TrieNode {
public:
    unordered_map<char, TrieNode*> children; // 存储子节点
    int count; // 记录以该节点结尾的字符串出现的次数

    TrieNode() : count(0) {} // 构造函数
};

class Trie {
private:
    TrieNode* root; // 根节点

public:
    Trie() {
        root = new TrieNode(); // 初始化根节点
    }

    // 插入字符串
    void insert(const string& word) {
        TrieNode* node = root;
        for (char c : word) {
            if (node->children.find(c) == node->children.end()) {
                node->children[c] = new TrieNode(); // 如果字符不存在，创建新节点
            }
            node = node->children[c]; // 移动到子节点
        }
        node->count++; // 只在字符串的结尾节点增加计数器
    }

    // 查询字符串出现的次数
    int search(const string& word) {
        TrieNode* node = root;
        for (char c : word) {
            if (node->children.find(c) == node->children.end()) {
                return 0; // 如果路径中断，返回0
            }
            node = node->children[c];
        }
        return node->count; // 返回计数器值
    }
};

int main() {
    Trie trie;

    // 插入一些字符串
    int n;
    cout << "输入n" << endl;
    cin >> n;
    trie.insert("apple");
    trie.insert("app");
    trie.insert("apricot");
    trie.insert("banana");
    trie.insert("bat");
    trie.insert("cat");
    trie.insert("car");
    trie.insert("car");
    trie.insert("car");
    trie.insert("app");

    // 查询字符串出现的次数
    cout << "apple: " << trie.search("apple") << endl; // 输出 1
    cout << "app: " << trie.search("app") << endl; // 输出 1
    cout << "apricot: " << trie.search("apricot") << endl; // 输出 1
    cout << "banana: " << trie.search("banana") << endl; // 输出 1
    cout << "bat: " << trie.search("bat") << endl; // 输出 1
    cout << "cat: " << trie.search("cat") << endl; // 输出 1
    cout << "car: " << trie.search("car") << endl; // 输出 1
    cout << "catar: " << trie.search("catar") << endl; // 输出 0

    return 0;
}
```

### LRU

```cpp
#include <iostream>
#include <list>
#include <unordered_map>
using namespace std;

class LRUCache {
private:
    int capacity;
    list<pair<int, int>> cache;
    unordered_map<int, list<pair<int, int>>::iterator> map;

public:
    LRUCache(int cap) : capacity(cap) {}

    int get(int key) {
        if (map.find(key) == map.end()) return -1;
        auto key_value = *map[key];
        cache.erase(map[key]);
        cache.push_front(key_value);
        map[key] = cache.begin();
        return key_value.second;
    }

    void put(int key, int value) {
        if (map.find(key) != map.end()) {
            cache.erase(map[key]);
        }
        else if (cache.size() == capacity) {
            map.erase(cache.back().first);
            cache.pop_back();
        }
        cache.push_front({ key, value });
        map[key] = cache.begin();
    }
    void printCache() const {
        cout << "Current LRU Cache: ";
        for (const auto& kv : cache) {
            cout << "(" << kv.first << ", " << kv.second << ") ";
        }
        cout << endl;
    }

};

int main() {
    int capacity;
    cout << "Enter LRU Cache capacity: ";
    cin >> capacity;
    LRUCache cache(capacity);
    while (true) {
        string op;
        cout << "Enter operation (get/put/exit): ";
        cin >> op;
        if (op == "get") {
            int key;
            cout << "Enter key: ";
            cin >> key;
            int value = cache.get(key);
            cout << "Value: " << value << endl;
            cache.printCache();
        }
        else if (op == "put") {
            int key, value;
            cout << "Enter key and value: ";
            cin >> key >> value;
            cache.put(key, value);
            cache.printCache();
        }
        else if (op == "exit") {
            break;
        }
        else {
            cout << "Invalid operation. Please try again." << endl;
        }
    }
    return 0;
}
#include <iostream>
#include <unordered_map>
#include <list>

using namespace std;

class LRUcache {

public:
	LRUcache(int cap) : capacity(cap) {}

	int get(int key) {
		if (map.find(key) == map.end()) return -1;
		int val = (*map[key]).second;
		l.erase(map[key]);
		l.push_front(pair<int, int>(key, val));
		map[key] = l.begin();
		return val;
	}

	void put(int key,int val) {
		if (map.find(key) != map.end()) {
			//(*map[key]).second = val;
			l.erase(map[key]);
		}
		else if (l.size() >= capacity) {
            map.erase(l.back().first);
			l.pop_back();
		}
		l.push_front(pair<int, int>(key, val));
		map[key] = l.begin();
	}

	void print() {
		for (auto& n : l) {
			cout << "(" << n.first << ',' << n.second << ")" << ' ';
		}
	}
private:
	int capacity;
	list<pair<int, int>> l;
	unordered_map<int, list<pair<int, int>>::iterator> map;
};

int main() {
	int cap;
	cout << "输入容量:" ;
	cin >> cap;
	LRUcache LRU(cap);
	while (true) {
		cout<<endl<< "输入操作put/get/exit?  :";
		string op;
		cin >> op;
		if (op == "get") {
			cout << "输入key ：";
			int key;
			cin >> key;
			int val = LRU.get(key);
			cout << val << endl;
			LRU.print();
		}

		else if (op == "put") {
			int key, val;
			cout << "输入key,val ：";
			cin >> key >> val;
			LRU.put(key, val);
			LRU.print();
		}

		else if (op == "exit") {
			return 0;
		}
		else {
			cout << "无效值" << endl;
		}
	}
	return 0;
}
```

## 环形队列缓冲区

```cpp
#include <iostream>   
#include <cstring>
   
class FixedQueue {   
private:
    char* buffer;          // 缓冲区
    size_t capacity;       // 缓冲区总容量
    size_t writeIndex;     // 写入位置
    size_t readIndex;      // 读取位置

    // 计算可用空间
    size_t availableSpace() const {
        if (writeIndex >= readIndex) {
            return capacity - (writeIndex - readIndex);
        } else {
            return readIndex - writeIndex;
        }
    }
   
public:
    // 构造函数，初始化缓冲区
    FixedQueue(size_t cap) : capacity(cap), writeIndex(0), readIndex(0) {
        buffer = new char[cap];
    }

    // 析构函数，释放缓冲区
    ~FixedQueue() {
        delete[] buffer;
    }

    // 生产者：向队列写入数据
    bool push(const char* data, size_t size) {
        if (availableSpace() < size) {
            return false; // 缓冲区空间不足
        }

        // 写入数据
        for (size_t i = 0; i < size; ++i) {
            buffer[writeIndex] = data[i];
            writeIndex = (writeIndex + 1) % capacity;
        }
        return true;
    }

    // 消费者：从队列读取数据
    bool pop(char* data, size_t size) {
        if ((writeIndex >= readIndex && (writeIndex - readIndex) < size) ||
            (writeIndex < readIndex && (capacity - readIndex + writeIndex) < size)) {
            return false; // 缓冲区数据不足
        }

        // 读取数据
        for (size_t i = 0; i < size; ++i) {
            data[i] = buffer[readIndex];
            readIndex = (readIndex + 1) % capacity;
        }
        return true;
    }   
};
   
int main() {
    FixedQueue queue(10); // 创建一个容量为10的队列

    // 生产者：写入数据
    const char* data1 = "Hello";
    if (queue.push(data1, strlen(data1))) {
        std::cout << "Pushed: " << data1 << std::endl;
    } else {
        std::cout << "Queue is full!" << std::endl;
    }

    const char* data2 = "World";
    if (queue.push(data2, strlen(data2))) {
        std::cout << "Pushed: " << data2 << std::endl;
    } else {
        std::cout << "Queue is full!" << std::endl;
    }

    // 消费者：读取数据
    char buffer[10];
    if (queue.pop(buffer, 5)) {
        buffer[5] = '\0'; // 添加字符串结束符
        std::cout << "Popped: " << buffer << std::endl;
    } else {
        std::cout << "Queue is empty!" << std::endl;
    }

    if (queue.pop(buffer, 5)) {
        buffer[5] = '\0'; // 添加字符串结束符
        std::cout << "Popped: " << buffer << std::endl;
    } else {
        std::cout << "Queue is empty!" << std::endl;
    }

    return 0;   
}
```

## 图

DFS

```cpp
#include <iostream>
#include <vector>
using namespace std;
vector<vector<int>> result; // 收集符合条件的路径
vector<int> path; // 1节点到终点的路径

void dfs (const vector<vector<int>>& graph, int x, int n) {
    // 当前遍历的节点x 到达节点n 
    if (x == n) { // 找到符合条件的一条路径
        result.push_back(path);
        return;
    }
    for (int i = 1; i <= n; i++) { // 遍历节点x链接的所有节点
        if (graph[x][i] == 1) { // 找到 x链接的节点
            path.push_back(i); // 遍历到的节点加入到路径中来
            dfs(graph, i, n); // 进入下一层递归
            path.pop_back(); // 回溯，撤销本节点
        }
    }
}

int main() {
    int n, m, s, t;
    cin >> n >> m;

    // 节点编号从1到n，所以申请 n+1 这么大的数组
    vector<vector<int>> graph(n + 1, vector<int>(n + 1, 0));

    while (m--) {
        cin >> s >> t;
        // 使用邻接矩阵 表示无线图，1 表示 s 与 t 是相连的
        graph[s][t] = 1;
    }

    path.push_back(1); // 无论什么路径已经是从0节点出发
    dfs(graph, 1, n); // 开始遍历

    // 输出结果
    if (result.size() == 0) cout << -1 << endl;
    for (const vector<int> &pa : result) {
        for (int i = 0; i < pa.size() - 1; i++) {
            cout << pa[i] << " ";
        }
        cout << pa[pa.size() - 1]  << endl;
    }
}
#include <iostream>
#include <vector>
#include <list>
using namespace std;

vector<vector<int>> result; // 收集符合条件的路径
vector<int> path; // 1节点到终点的路径

void dfs (const vector<list<int>>& graph, int x, int n) {

    if (x == n) { // 找到符合条件的一条路径
        result.push_back(path);
        return;
    }
    for (int i : graph[x]) { // 找到 x指向的节点
        path.push_back(i); // 遍历到的节点加入到路径中来
        dfs(graph, i, n); // 进入下一层递归
        path.pop_back(); // 回溯，撤销本节点
    }
}

int main() {
    int n, m, s, t;
    cin >> n >> m;

    // 节点编号从1到n，所以申请 n+1 这么大的数组
    vector<list<int>> graph(n + 1); // 邻接表
    while (m--) {
        cin >> s >> t;
        // 使用邻接表 ，表示 s -> t 是相连的
        graph[s].push_back(t);

    }

    path.push_back(1); // 无论什么路径已经是从0节点出发
    dfs(graph, 1, n); // 开始遍历

    // 输出结果
    if (result.size() == 0) cout << -1 << endl;
    for (const vector<int> &pa : result) {
        for (int i = 0; i < pa.size() - 1; i++) {
            cout << pa[i] << " ";
        }
        cout << pa[pa.size() - 1]  << endl;
    }
}
```

BFS

```cpp
int dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1}; // 表示四个方向
// grid 是地图，也就是一个二维数组
// visited标记访问过的节点，不要重复访问
// x,y 表示开始搜索节点的下标
void bfs(vector<vector<char>>& grid, vector<vector<bool>>& visited, int x, int y) {
    queue<pair<int, int>> que; // 定义队列
    que.push({x, y}); // 起始节点加入队列
    visited[x][y] = true; // 只要加入队列，立刻标记为访问过的节点
    while(!que.empty()) { // 开始遍历队列里的元素
        pair<int ,int> cur = que.front(); 
        que.pop(); // 从队列取元素
        int curx = cur.first;
        int cury = cur.second; // 当前节点坐标
        for (int i = 0; i < 4; i++) { // 开始想当前节点的四个方向左右上下去遍历
            int nextx = curx + dir[i][0];
            int nexty = cury + dir[i][1]; // 获取周边四个方向的坐标
            if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;  // 坐标越界了，直接跳过
            if (!visited[nextx][nexty]) { // 如果节点没被访问过
                que.push({nextx, nexty});  // 队列添加该节点为下一轮要遍历的节点
                visited[nextx][nexty] = true; // 只要加入队列立刻标记，避免重复访问
            }
        }
    }

}
void bfs(const vector<list<int>>& graph, vector<bool>& visited, int start) {
    queue<int> que;         // 队列存储节点编号
    que.push(start);        // 起始节点入队
    visited[start] = true;  // 立即标记为已访问

    while (!que.empty()) {
        int cur = que.front();  
        que.pop();

        // 遍历当前节点的所有邻居（邻接表特性）
        // 注意：graph[cur] 返回的是 const list<int>&（因为 graph 是 const 引用）
        for (int neighbor : graph.at(cur)) { // 使用 at() 保证 const 正确性
            if (!visited[neighbor]) {
                que.push(neighbor);  
                visited[neighbor] = true;  
            }
        }
    }
}
```

## 实现内存拷贝，两种

```cpp
char* strcpy(char *dst,const char *src) {// [1] 
    assert(dst != NULL && src != NULL);  // [2]
    char *ret = dst;                     // [3]
    while ((*dst++=*src++)!='\0');       // [4]
    return ret;
}
char * strcpy(char *dst,const char *src)
{
    assert(dst != NULL && src != NULL);
    char *ret = dst;
    my_memcpy(dst, src, strlen(src)+1);
    return ret;
}

/* my_memcpy的实现如下 */
char *my_memcpy(char *dst, const char* src, int cnt)
{
    assert(dst != NULL && src != NULL);
    char *ret = dst;
    /*内存重叠，从高地址开始复制*/
    if (dst >= src && dst <= src+cnt-1)
    {
        dst = dst+cnt-1;
        src = src+cnt-1;
        while (cnt--) 
        { 
            *dst-- = *src--;
        }
    }
    else  //正常情况，从低地址开始复制
    {
        while (cnt--) 
        {
            *dst++ = *src++;
        }
    }
    return ret;
}
```

## 并查集模板

```cpp
int n = 1005; // n根据题目中节点数量而定，一般比节点数量大一点就好
vector<int> father = vector<int> (n, 0); // C++里的一种数组结构

// 并查集初始化
void init() {
    for (int i = 0; i < n; ++i) {
        father[i] = i;
    }
}
// 并查集里寻根的过程
int find(int u) {
    return u == father[u] ? u : father[u] = find(father[u]); // 路径压缩
}

// 判断 u 和 v是否找到同一个根
bool isSame(int u, int v) {
    u = find(u);
    v = find(v);
    return u == v;
}

// 将v->u 这条边加入并查集
void join(int u, int v) {
    u = find(u); // 寻找u的根
    v = find(v); // 寻找v的根
    if (u == v) return ; // 如果发现根相同，则说明在一个集合，不用两个节点相连直接返回
    father[v] = u;
}
```

## Bellman_ford算法

```cpp
#include <iostream>
#include <vector>
#include <list>
#include <climits>
using namespace std;

int main() {
    int n, m, p1, p2, val;
    cin >> n >> m;

    vector<vector<int>> grid;

    // 将所有边保存起来
    for(int i = 0; i < m; i++){
        cin >> p1 >> p2 >> val;
        // p1 指向 p2，权值为 val
        grid.push_back({p1, p2, val});

    }
    int start = 1;  // 起点
    int end = n;    // 终点

    vector<int> minDist(n + 1 , INT_MAX);
    minDist[start] = 0;
    for (int i = 1; i < n; i++) { // 对所有边 松弛 n-1 次
        for (vector<int> &side : grid) { // 每一次松弛，都是对所有边进行松弛
            int from = side[0]; // 边的出发点
            int to = side[1]; // 边的到达点
            int price = side[2]; // 边的权值
            // 松弛操作 
            // minDist[from] != INT_MAX 防止从未计算过的节点出发
            if (minDist[from] != INT_MAX && minDist[to] > minDist[from] + price) { 
                minDist[to] = minDist[from] + price;  
            }
        }
    }
    if (minDist[end] == INT_MAX) cout << "unconnected" << endl; // 不能到达终点
    else cout << minDist[end] << endl; // 到达终点最短路径

}
#include <iostream>
#include <vector>
#include <climits>
using namespace std;

int main() {
    int n, m; // n: 节点数, m: 边数
    cin >> n >> m;

    // 邻接矩阵初始化：grid[i][j]表示从i到j的边的权值，默认INT_MAX表示无边
    vector<vector<int>> grid(n + 1, vector<int>(n + 1, INT_MAX));

    // 输入边信息并填充邻接矩阵
    for (int i = 0; i < m; i++) {
        int p1, p2, val;
        cin >> p1 >> p2 >> val;
        grid[p1][p2] = val; // p1 -> p2 的权值为val（注意：邻接矩阵不存储反向边）
    }

    int start = 1;  // 起点
    int end = n;    // 终点

    vector<int> minDist(n + 1, INT_MAX);
    minDist[start] = 0;

    // Bellman-Ford核心算法：松弛n-1次
    for (int i = 1; i < n; i++) { // 松弛n-1轮
        // 每一轮对所有可能的边（i->j）进行松弛
        for (int from = 1; from <= n; from++) {
            if (minDist[from] == INT_MAX) continue; // 跳过不可达的起点
            for (int to = 1; to <= n; to++) {
                if (grid[from][to] != INT_MAX) { // 如果存在from->to的边
                    if (minDist[to] > minDist[from] + grid[from][to]) {
                        minDist[to] = minDist[from] + grid[from][to];
                    }
                }
            }
        }
        cout << "对所有边松弛 "<< i << "次" << endl;
        for (int k = 1; k <= n; k++) {
            cout << minDist[k] << " ";
        }
        cout << endl;
    }

    if (minDist[end] == INT_MAX) {
        cout << "unconnected" << endl;
    } else {
        cout << minDist[end] << endl;
    }
}
```

## SPFA算法

```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <climits>
using namespace std;

int main() {
    int n, m; // n: 节点数, m: 边数
    cin >> n >> m;

    // 邻接矩阵初始化：grid[i][j]表示从i到j的边的权值，默认INT_MAX表示无边
    vector<vector<int>> grid(n + 1, vector<int>(n + 1, INT_MAX));

    // 输入边信息并填充邻接矩阵
    for (int i = 0; i < m; i++) {
        int p1, p2, val;
        cin >> p1 >> p2 >> val;
        grid[p1][p2] = val; // p1 -> p2 的权值为val（注意：邻接矩阵不存储反向边）
    }

    int start = 1;  // 起点
    int end = n;    // 终点

    vector<int> minDist(n + 1, INT_MAX);
    minDist[start] = 0;

    queue<int> que;
    que.push(start);

    vector<bool> isInQueue(n + 1, false); // 标记节点是否在队列中
    isInQueue[start] = true; // 起点加入队列

    while (!que.empty()) {
        int node = que.front();
        que.pop();
        isInQueue[node] = false; // 从队列取出后取消标记

        // 遍历所有可能的邻接节点（通过邻接矩阵）
        for (int neighbor = 1; neighbor <= n; neighbor++) {
            if (grid[node][neighbor] != INT_MAX) { // 如果存在node->neighbor的边
                int newDist = minDist[node] + grid[node][neighbor];
                if (minDist[neighbor] > newDist) { // 松弛操作
                    minDist[neighbor] = newDist;
                    if (!isInQueue[neighbor]) { // 如果邻居不在队列中
                        que.push(neighbor);
                        isInQueue[neighbor] = true;
                    }
                }
            }
        }
    }

    if (minDist[end] == INT_MAX) {
        cout << "unconnected" << endl;
    } else {
        cout << minDist[end] << endl;
    }
}
#include <iostream>
#include <vector>
#include <queue>
#include <list>
#include <climits>
using namespace std;

struct Edge { //邻接表
    int to;  // 链接的节点
    int val; // 边的权重

    Edge(int t, int w): to(t), val(w) {}  // 构造函数
};


int main() {
    int n, m, p1, p2, val;
    cin >> n >> m;

    vector<list<Edge>> grid(n + 1); 

    vector<bool> isInQueue(n + 1); // 加入优化，已经在队里里的元素不用重复添加

    // 将所有边保存起来
    for(int i = 0; i < m; i++){
        cin >> p1 >> p2 >> val;
        // p1 指向 p2，权值为 val
        grid[p1].push_back(Edge(p2, val));
    }
    int start = 1;  // 起点
    int end = n;    // 终点

    vector<int> minDist(n + 1 , INT_MAX);
    minDist[start] = 0;

    queue<int> que;
    que.push(start); 

    while (!que.empty()) {

        int node = que.front(); que.pop();
        isInQueue[node] = false; // 从队列里取出的时候，要取消标记，我们只保证已经在队列里的元素不用重复加入
        for (Edge edge : grid[node]) {
            int from = node;
            int to = edge.to;
            int value = edge.val;
            if (minDist[to] > minDist[from] + value) { // 开始松弛
                minDist[to] = minDist[from] + value; 
                if (isInQueue[to] == false) { // 已经在队列里的元素不用重复添加
                    que.push(to);
                    isInQueue[to] = true;
                }
            }
        }

    }
    if (minDist[end] == INT_MAX) cout << "unconnected" << endl; // 不能到达终点
    else cout << minDist[end] << endl; // 到达终点最短路径
}
```

## 多线程

```cpp
#include <iostream>
#include <thread>
#include <mutex>
#include <condition_variable>
#include <atomic>

std::mutex mtx;
std::condition_variable cv;
std::atomic<int> count{ 1 };

void print(int id) {
    while (true) {
        std::unique_lock<std::mutex> lock(mtx);
        cv.wait(lock, [id] { return count % 3 == id - 1; }); // 等待条件满足
        if (count > 100) break; // 超出范围退出
        std::cout << count << " ";
        count++; // 更新计数器
        cv.notify_all(); // 通知其他线程
    }
}

int main() {
    std::thread t1(print, 1);
    std::thread t2(print, 2);
    std::thread t3(print, 3);

    t1.join();
    t2.join();
    t3.join();

    return 0;
}
#include <iostream>
#include <mutex>

class LazySingleton {
    public:
    static LazySingleton* getInstance() {
        if (instance == nullptr) {  // 第一次检查
            lock_guard<mutex> lock(mtx);  // 加锁，保证线程安全
            if (instance == nullptr) {  // 第二次检查
                instance = new LazySingleton();
            }
        }
        return instance;
    }

    LazySingleton(const LazySingleton&) = delete;
    LazySingleton& operator=(const LazySingleton&) = delete;

    private:
    LazySingleton() {}
    ~LazySingleton() {}
    static LazySingleton* instance;  // 静态指针成员
    static mutex mtx;           // 静态互斥锁，保证线程安全
};
// 初始化静态成员
LazySingleton* LazySingleton::instance = nullptr;
mutex LazySingleton::mtx;


int main() {
    LazySingleton* singleton = LazySingleton::getInstance();
    singleton->doSomething();

    return 0;
}
#include <iostream>

class EagerSingleton {
public:
static EagerSingleton& getInstance() {
    return instance;
}

EagerSingleton(const EagerSingleton&) = delete;
EagerSingleton& operator=(const EagerSingleton&) = delete;
void doSomething() {}

private:
EagerSingleton() {}
~EagerSingleton() {}

static EagerSingleton instance;
};
// 初始化静态成员变量
EagerSingleton EagerSingleton::instance;

int main() {
    EagerSingleton& singleton = EagerSingleton::getInstance();
    singleton.doSomething();

    return 0;
}
```

###### 手撕智能指针

![img](https://cdn.nlark.com/yuque/0/2025/png/45967853/1744018419155-23059f0e-563a-4d3d-b2ef-caa0a3f9aaf6.png)

###### 代码

```cpp
#include <iostream>   
#include <vector>   
#include <stack>

// 检查序列是否为合法的出入栈序列   
bool isValid(const std::vector<int>& seq) {
    std::stack<int> stk;
    for (int num : seq) {
        if (num > 0) {
            stk.push(num);
        }
        else {
            if (stk.empty() || stk.top() != -num) {
                return false;
            }
            stk.pop();
        }
    }
    return stk.empty();
}

// 寻找需要交换的相邻元素对   
std::pair<int, int> findSwapPair(const std::vector<int>& seq) {
    int n = seq.size();
    for (int i = 0; i < n - 1; ++i) {
        std::vector<int> newSeq = seq;
        std::swap(newSeq[i], newSeq[i + 1]);
        if (isValid(newSeq)) {
            return { i + 1, i + 2 };
        }
    }
    return { -1, -1 };
}

int main() {
    int n;
    std::cin >> n;
    std::vector<int> sequence(n);
    for (int i = 0; i < n; ++i) {
        std::cin >> sequence[i];
    }
    std::pair<int, int> result = findSwapPair(sequence);
    std::cout << result.first << " " << result.second << std::endl;
    return 0;
}
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

typedef pair<int, int> PII;
long long countIntersectingPairs(int n, vector<PII>& intervals) {
    sort(intervals.begin(), intervals.end());
    long long ans = 0;
    int right = 0;
    for (int left = 0; left < n; ++left) {
        while (right < n && intervals[right].first <= intervals[left].second) {
            right++;
        }
        ans += right - left - 1;
    }
    return ans;
}

int main() {
    int n;
    cin >> n;
    vector<PII> intervals(n);
    for (int i = 0; i < n; ++i) {
        cin >> intervals[i].first >> intervals[i].second;
    }
    cout << countIntersectingPairs(n, intervals) << endl;
    return 0;
}
#include <iostream>   
#include <string>   
#include <vector>

const int MOD = 1e9 + 7;

// 计算合法演奏方式数量   
int countWays(const std::string& s) {
    int n = s.size();
    std::vector<int> dp(n + 1, 0);
    dp[0] = 1;
    if (s[0] != '0') {
        dp[1] = 1;
    }
    for (int i = 2; i <= n; ++i) {
        int single = s[i - 1] - '0';
        int double_num = (s[i - 2] - '0') * 10 + (s[i - 1] - '0');
        if (single >= 1 && single <= 9) {
            dp[i] = (dp[i] + dp[i - 1]) % MOD;
        }
        if (double_num >= 10 && double_num <= 26) {
            dp[i] = (dp[i] + dp[i - 2]) % MOD;
        }
    }
    return dp[n];
}

int main() {
    int T;
    std::cin >> T;
    for (int i = 0; i < T; ++i) {
        int n;
        std::cin >> n;
        std::string s;
        std::cin >> s;
        std::cout << countWays(s) << std::endl;
    }
    return 0;
}

        if (single >= 1 && single <= 9) {
            dp[i] =  dp[i - 1] % MOD;
        }
        if (double_num >= 10 && double_num <= 26) {
            dp[i] = (dp[i] + dp[i - 2]) % MOD;
        }
```

##### KMP算法

![img](https://cdn.nlark.com/yuque/0/2025/png/45967853/1745141945207-6e81c3f6-c02f-4b4f-aaf5-b3ecd0f926a0.png)

![img](https://cdn.nlark.com/yuque/0/2025/png/45967853/1745141950084-c9e5a8f4-4841-4861-85be-ee258339db3a.png)

```cpp
#include <iostream>
#include <vector>
#include <string>

// 函数：计算next数组
std::vector<int> computeNextArray(const std::string& pattern) {
    int patternLength = pattern.length();
    std::vector<int> next(patternLength, 0); // 初始化next数组
    int i = 0; // 当前位置
    int j = -1; // 前一个位置
    next[0] = -1; // next数组的第一个值总是-1

    while (i < patternLength - 1) {
        if (j == -1 || pattern[i] == pattern[j]) {
            i++;
            j++;
            next[i] = j; // 如果当前字符匹配，next[i] = j
        } else {
            j = next[j]; // 如果不匹配，j回退到next[j]
        }
    }

    return next;
}

int main() {
    std::string pattern = "abababca"; // 模式字符串
    std::vector<int> next = computeNextArray(pattern); // 计算next数组

    // 输出next数组
    std::cout << "Next数组：\n";
    for (size_t i = 0; i < next.size(); ++i) {
        std::cout << "next[" << i << "] = " << next[i] << std::endl;
    }

    return 0;
}
#include <iostream>
#include <vector>
#include <string>

// 函数：计算next数组
std::vector<int> computeNextArray(const std::string& pattern) {
    int patternLength = pattern.length();
    std::vector<int> next(patternLength, 0); // 初始化next数组
    int i = 0; // 当前位置
    int j = -1; // 前一个位置
    next[0] = -1; // next数组的第一个值总是-1

    while (i < patternLength - 1) {
        if (j == -1 || pattern[i] == pattern[j]) {
            i++;
            j++;
            next[i] = j; // 如果当前字符匹配，next[i] = j
        } else {
            j = next[j]; // 如果不匹配，j回退到next[j]
        }
    }

    return next;
}

// 函数：KMP字符串匹配算法
int kmpSearch(const std::string& text, const std::string& pattern) {
    int textLength = text.length();
    int patternLength = pattern.length();

    if (patternLength == 0) return 0; // 空模式匹配任何字符串的开始位置
    if (textLength < patternLength) return -1; // 文本比模式短，直接返回-1

    std::vector<int> next = computeNextArray(pattern); // 计算next数组
    int i = 0; // 文本的索引
    int j = 0; // 模式的索引

    while (i < textLength) {
        if (j == -1 || text[i] == pattern[j]) {
            i++;
            j++;
            if (j == patternLength) {
                return i - j; // 匹配成功，返回起始位置
            }
        } else {
            j = next[j]; // 不匹配时，j回退到next[j]
        }
    }

    return -1; // 未找到匹配
}

int main() {
    std::string text = "ababababca"; // 文本字符串
    std::string pattern = "abababca"; // 模式字符串

    std::vector<int> next = computeNextArray(pattern); // 计算next数组

    // 输出next数组
    std::cout << "Next数组：\n";
    for (size_t i = 0; i < next.size(); ++i) {
        std::cout << "next["<< i << "] = " << next[i] << std::endl;
    }

    // 执行KMP搜索
    int matchIndex = kmpSearch(text, pattern);

    // 输出匹配结果
    if (matchIndex != -1) {
        std::cout << "模式 \"" << pattern << "\" 在文本 \"" << text << "\" 中的起始位置: " << matchIndex << std::endl;
    } else {
        std::cout << "模式 \"" << pattern << "\" 未在文本 \"" << text << "\" 中找到。" << std::endl;
    }

    return 0;
}
#include <iostream>
#include <memory>
using namespace std;

// BF算法    时间复杂度：O(n)*O(m) =  O(n*m)   空间复杂度： O(1)
int BF(string s, string t)
{
	int i = 0;
	int j = 0;

	while (i < s.size() && j < t.size())  // O(n)
	{
		if (s[i] == t[j])
		{
			i++;
			j++;
		}
		else
		{
			i = i - j + 1; // 复位i，指向之前开始匹配字符的下一个字符  O(m)
			j = 0;
		}
	}

	if (j == t.size()) // 找到了
	{
		return i - j;
	}
	else
	{
		return -1;
	}
}

// KMP算法求解子串的next数组
int* getNext(string str)
{
	int* next = new int[str.size()];
	int j = 0; // j用来遍历子串
	int k = -1; // k表示公共前后缀的长度
	next[j] = k;

	while (j < str.size() - 1)   // O(m)
	{
		if (-1 == k || str[k] == str[j])
		{
			j++;
			k++;
            next[j] = k;
			//if (str[k] == str[j])
			//{
				// kmp算法的优化
				//next[j] = next[k];
			//}
			//else
			//{
			//	next[j] = k;
			//}
		}
		else
		{
			k = next[k]; // 做k值回溯，继续找最长的公共前后缀
		}
	}

	return next;
}

// KMP算法  时间复杂度：O(n) + O(m) = O(n+m)  空间复杂度：O(m)
int KMP(string s, string t)
{
	int i = 0;
	int j = 0;

	// 计算一个子串对应的next数组
	int* next = getNext(t);
	unique_ptr<int> ptr(next);  // delete操作

	cout << t << " : ";
	for (int m = 0; m < t.size(); m++)
	{
		cout << next[m] << " ";
	}
	cout << endl;

	// j < t.size() 有问题！！！ j = -1 11111111111  size_t  unsigned int
	int size1 = s.size();
	int size2 = t.size();
	while (i < size1 && j < size2)   // O(n)
	{
		if (-1 == j || s[i] == t[j])
		{
			i++;
			j++;
		}
		else
		{
			// KMP的核心是不回退i，只回退j值 
			j = next[j];  // 如果首字母匹配失败，这里j == -1

			//i = i - j + 1; 
			//j = 0;
		}
	}

	if (j == t.size()) // 找到了
	{
		return i - j;
	}
	else
	{
		return -1;
	}
}

int main()
{
	string s = "abcabdefabcabc"; //"ABCDCABDEFG";
	string t = "abcabc"; //"ABD";

	int pos = KMP(s, t);
	cout << pos << endl;
}
```

![img](https://cdn.nlark.com/yuque/0/2025/jpeg/45967853/1743059993985-f0209abc-00d6-4aef-8171-c20febb53cd1.jpeg)

![img](https://cdn.nlark.com/yuque/0/2025/png/45967853/1743140361170-f46f68c3-6ea9-4789-b111-a0901a8c6d0d.png)![img](https://cdn.nlark.com/yuque/0/2025/png/45967853/1743143719915-cb6aee45-e564-4e5f-9001-1d2b5ddd7b36.png)

| 函数         | 作用                                                  | 返回值                                 |
| ------------ | ----------------------------------------------------- | -------------------------------------- |
| `isdigit(c)` | 检查 `c` 是否是数字字符（`'0'`-`'9'`）                | `true`（是数字）或 `false`（不是数字） |
| `isalpha(c)` | 检查 `c` 是否是字母字符（`'a'`-`'z'` 或 `'A'`-`'Z'`） | `true`（是字母）或 `false`（不是字母） |

| 函数         | 作用                                                         | 返回值            |
| ------------ | ------------------------------------------------------------ | ----------------- |
| `islower(c)` | 检查 `c` 是否是小写字母（`'a'`-`'z'`）                       | `true` 或 `false` |
| `isupper(c)` | 检查 `c` 是否是大写字母（`'A'`-`'Z'`）                       | `true` 或 `false` |
| `tolower(c)` | 将 `c` 转换为小写字母（非字母不受影响）                      | 转换后的字符      |
| `toupper(c)` | 将 `c` 转换为大写字母（非字母不受影响）                      | 转换后的字符      |
| `isalnum(c)` | 检查 `c` 是否是字母或数字（`'a'`-`'z'`, `'A'`-`'Z'`, `'0'`-`'9'`） | `true` 或 `false` |
| `ispunct(c)` | 检查 `c` 是否是标点符号（如 `'!'`, `'@'`, `'$'` 等）         | `true` 或 `false` |
| `iscntrl(c)` | 检查 `c` 是否是控制字符（如 `'\0'`, `'\n'` 等）              | `true` 或 `false` |

![img](https://cdn.nlark.com/yuque/0/2025/png/45967853/1753947316497-d144efcd-1d9d-4c39-a775-5130944e8126.png)

## 多态实现

```cpp
#include <iostream>
#include <map>
#include <string>

// 基类：配置管理器
class ConfigManager {
public:
    virtual ~ConfigManager() = default;

    // 设置配置项
    virtual void setConfig(const std::string& key, const std::string& value) {
        configs_[key] = value;
    }

    // 获取配置项
    virtual std::string getConfig(const std::string& key) const {
        auto it = configs_.find(key);
        if (it != configs_.end()) {
            return it->second;
        }
        return ""; 
    }

    // 打印所有配置项（虚函数，用于多态）
    virtual void printAllConfigs() const = 0;

protected:
    std::map<std::string, std::string> configs_;
};

// 派生类：Nginx 配置管理器
class NginxConfigManager : public ConfigManager {
public:
    NginxConfigManager() {
        // 初始化默认配置
        configs_["timeout"] = "60";
        configs_["worker_connections"] = "1024";
        configs_["access_log"] = "access.log";
    }

    void printAllConfigs() const override {
        std::cout << "[nginx]" << std::endl;
        for (const auto& pair : configs_) {
            std::cout << pair.first << "=" << pair.second << std::endl;
        }
    }
};

// 派生类：MySQL 配置管理器
class MySQLConfigManager : public ConfigManager {
public:
    MySQLConfigManager() {
        // 初始化默认配置
        configs_["max_connections"] = "500";
        configs_["slow_query_log"] = "1";
    }

    void setConfig(const std::string& key, const std::string& value) override {
        if (key == "max_connections") {
            int val = std::stoi(value); // 转为整数进行校验
            if (val < 1 || val > 1000) {
                throw std::out_of_range("max_connections 必须在 [1, 1000] 范围内");
            }
        }
        configs_[key] = value;
    }

    void printAllConfigs() const override {
        std::cout << "[mysql]" << std::endl;
        for (const auto& pair : configs_) {
            std::cout << pair.first << "=" << pair.second << std::endl;
        }
    }
};

// ========== 测试代码 ==========
int main() {

        // 创建 Nginx 和 MySQL 配置管理器
        NginxConfigManager nginx;
        MySQLConfigManager mysql;

        // 打印初始配置
        std::cout << "初始配置：" << std::endl;
        nginx.printAllConfigs();
        mysql.printAllConfigs();

        std::cout << "\n修改配置后：" << std::endl;

        // 修改 Nginx 的 access_log
        nginx.setConfig("access_log", "new_access.log");
        // 修改 MySQL 的 max_connections（合法值）
        mysql.setConfig("max_connections", "800");
        // 你也可以尝试设置一个非法值，比如 mysql.setConfig("max_connections", "2000"); // 会抛异常

        // 再次打印配置
        nginx.printAllConfigs();
        mysql.printAllConfigs();

    return 0;
}
```

## 构建链表

```cpp
#include <iostream>
using namespace std;

// 定义链表节点
struct ListNode {
    int val;
    ListNode *next;
    ListNode() : val(0), next(nullptr) {}
    ListNode(int x) : val(x), next(nullptr) {}
    ListNode(int x, ListNode *next) : val(x), next(next) {}
};

// 辅助函数：从数组构建链表（模拟输入）
ListNode* buildList(int arr[], int n) {
    if (n == 0) return nullptr;
    ListNode *head = new ListNode(arr[0]);
    ListNode *current = head;
    for (int i = 1; i < n; i++) {
        current->next = new ListNode(arr[i]);
        current = current->next;
    }
    return head;
}

// 辅助函数：打印链表
void printList(ListNode *head) {
    ListNode *current = head;
    while (current != nullptr) {
        cout << current->val;
        if (current->next != nullptr) {
            cout << " -> ";
        }
        current = current->next;
    }
    cout << endl;
}

// 辅助函数：释放链表内存
void freeList(ListNode *head) {
    ListNode *current = head;
    while (current != nullptr) {
        ListNode *temp = current;
        current = current->next;
        delete temp;
    }
}

// 主逻辑：移除链表中所有值为 val 的节点（修复内存泄漏）
class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) {
        ListNode* dummy = new ListNode(0, head); // 虚拟头节点
        ListNode* curr = dummy;
        while (curr->next != nullptr) {
            if (curr->next->val == val) {
                ListNode* toDelete = curr->next;
                curr->next = curr->next->next;
                delete toDelete; // 手动释放被删除的节点
            } else {
                curr = curr->next;
            }
        }
        ListNode* result = dummy->next;
        delete dummy; // 释放虚拟头节点
        return result;
    }
};

int main() {
    // 示例输入（模拟 ACM 模式输入）
    int n, val;
    cout << "请输入链表长度 n 和要删除的值 val: ";
    cin >> n >> val;

    int arr[n];
    cout << "请输入链表元素（空格分隔）: ";
    for (int i = 0; i < n; i++) {
        cin >> arr[i];
    }

    // 构建链表
    ListNode *head = buildList(arr, n);

    // 打印原始链表
    cout << "原始链表: ";
    printList(head);

    // 移除指定值的节点
    Solution solution;
    ListNode *newHead = solution.removeElements(head, val);

    // 打印处理后的链表
    cout << "删除 " << val << " 后的链表: ";
    printList(newHead);

    // 释放内存（避免泄漏）
    freeList(newHead);

    return 0;
}
```

## 构建树

```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <climits> // 用于 INT_MIN
using namespace std;

struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};

TreeNode* buildTree(const vector<int>& nums) {
    if (nums.empty() || nums[0] == INT_MIN) return nullptr;
    
    TreeNode *root = new TreeNode(nums[0]);
    queue<TreeNode*> q;
    q.push(root);
    
    int i = 1;
    while (!q.empty() && i < nums.size()) {
        TreeNode *curr = q.front();
        q.pop();
        
        if (i < nums.size() && nums[i] != INT_MIN) {
            curr->left = new TreeNode(nums[i]);
            q.push(curr->left);
        }
        i++;
        
        if (i < nums.size() && nums[i] != INT_MIN) {
            curr->right = new TreeNode(nums[i]);
            q.push(curr->right);
        }
        i++;
    }
    return root;
}

void printTree(TreeNode *root) {
    if (!root) {
        cout << "空树" << endl;
        return;
    }
    queue<TreeNode*> q;
    q.push(root);
    while (!q.empty()) {
        TreeNode *curr = q.front();
        q.pop();
        cout << curr->val << " ";
        if (curr->left) q.push(curr->left);
        if (curr->right) q.push(curr->right);
    }
    cout << endl;
}

void freeTree(TreeNode *root) {
    if (!root) return;
    queue<TreeNode*> q;
    q.push(root);
    while (!q.empty()) {
        TreeNode *curr = q.front();
        q.pop();
        if (curr->left) q.push(curr->left);
        if (curr->right) q.push(curr->right);
        delete curr;
    }
}

int main() {
    vector<int> nums = {1, 2, 3, INT_MIN, 4, INT_MIN, 5}; // INT_MIN 表示空节点
    TreeNode *root = buildTree(nums);
    printTree(root); // 输出: 1 2 3 4 5
    freeTree(root);
    return 0;
}
```

## 智能指针

```cpp
#include <iostream>
#include <atomic>

// 简化版 SharedPtr（线程安全的引用计数智能指针）
template <typename T>
class SharedPtr {
private:
    T* ptr_;                      // 指向管理的对象
    std::atomic<size_t>* count_;  // 引用计数（原子，线程安全）

    // 增加引用计数
    void add_ref() {
        if (count_) {
            (*count_)++;
        }
    }

    // 减少引用计数，如果为 0 则释放资源
    void release() {
        if (count_ && --(*count_) == 0) {
            delete ptr_;   // 删除托管对象
            delete count_; // 删除引用计数器
            ptr_ = nullptr;
            count_ = nullptr;
        }
    }

public:
    // 默认构造函数
    SharedPtr() : ptr_(nullptr), count_(nullptr) {}

    // 裸指针构造函数
    explicit SharedPtr(T* ptr)
        : ptr_(ptr), count_(new std::atomic<size_t>(1)) {}

    // 拷贝构造函数
    SharedPtr(const SharedPtr& other)
        : ptr_(other.ptr_), count_(other.count_) {
        add_ref();  // 引用计数 +1
    }

    // 拷贝赋值运算符
    SharedPtr& operator=(const SharedPtr& other) {
        if (this != &other) {
            release();         // 释放当前资源

            ptr_ = other.ptr_;
            count_ = other.count_;
            add_ref();         // 引用计数 +1
        }
        return *this;
    }

    // 析构函数
    ~SharedPtr() {
        release();
    }

    // 解引用操作符
    T& operator*() const {
        return *ptr_;
    }

    // 箭头操作符
    T* operator->() const {
        return ptr_;
    }

    // 获取原始指针
    T* get() const {
        return ptr_;
    }

    // 获取引用计数
    size_t use_count() const {
        return count_ ? count_->load() : 0;
    }

    // 重置指针
    void reset(T* ptr = nullptr) {
        release();  // 先释放当前资源

        if (ptr) {
            ptr_ = ptr;
            count_ = new std::atomic<size_t>(1);
        } else {
            ptr_ = nullptr;
            count_ = nullptr;
        }
    }
};
```

## 单例模式

```cpp
#include <iostream>

class Singleton {
public:
    // 获取单例实例（线程安全，C++11 保证局部静态变量初始化线程安全）
    static Singleton& getInstance() {
        static Singleton instance;  // 第一次调用时初始化，后续直接返回
        return instance;
    }

    // 示例方法
    void doSomething() {
        std::cout << "Singleton is doing something!" << std::endl;
    }

    // 禁止拷贝和赋值（防止多个实例）
    Singleton(const Singleton&) = delete;
    Singleton& operator=(const Singleton&) = delete;

private:
    // 私有构造函数和析构函数（防止外部 new 或 delete）
    Singleton() = default;
    ~Singleton() = default;
};

int main() {
    // 获取单例实例
    Singleton& singleton1 = Singleton::getInstance();
    Singleton& singleton2 = Singleton::getInstance();

    // 调用方法
    singleton1.doSomething();  // 输出: Singleton is doing something!
    singleton2.doSomething();  // 输出: Singleton is doing something!

    // 检查是否是同一个实例
    if (&singleton1 == &singleton2) {
        std::cout << "singleton1 和 singleton2 是同一个实例！" << std::endl;
    } else {
        std::cout << "singleton1 和 singleton2 不是同一个实例！" << std::endl;
    }

    return 0;
}
```

## 生产者消费者

```cpp
#include <deque>
#include <mutex>
#include <condition_variable>
template <typename T>
class DataQueue
{
public:
    DataQueue(){};
    ~DataQueue(){};

    void push(T& value)
    {
        std::lock_guard<std::mutex> lk(m); 
        if (queue.size() >= MAX_LEN)
            queue.pop_front();
        queue.push_back(std::move(value));
        cond.notify_one();
    }
    void wait_push(T& value)
    {
        std::unique_lock<std::mutex> lk(m);
        cond.wait(lk,[this](){return queue.size()<MAX_LEN;});
        queue.push_back(std::move(value));
        cond.notify_one();
    }
    bool try_pop(T& value)
    {
        std::lock_guard<std::mutex> lk(m); 
        if(!queue.empty())
            return false;
        value = queue.front();
        queue.pop_front();
        return true;                                                                      
    }
    void wait_pop(T& value)
    {
        std::unique_lock<std::mutex> lk(m);
        cond.wait(lk,[this](){return !queue.empty();});
        value = queue.front();
        queue.pop_front();
        
    }
    void clear()
    {
        std::lock_guard<std::mutex> lk(m); 
        queue.clear();
    };
    bool empty() const
    {
        std::lock_guard<std::mutex> lk(m); 
        return queue.empty();
    } 
    int size() const
    {
        std::lock_guard<std::mutex> lk(m); 
        return queue.size();
    } 
private:
    mutable std::mutex m;
    std::condition_variable cond;
    std::deque<T> queue;
    const int MAX_LEN = 200;
};


int main() {
    DataQueue<int> queue;

    // 生产者：往队列里放数据
    auto producer = [&queue](int id) {
        for (int i = 0; i < 5; ++i) {  // 每个生产者生产 5 个数据
            int data = id * 100 + i;
            queue.wait_push(data);  // 如果队列满了就阻塞等待
            std::cout << "Producer " << id << " pushed: " << data << std::endl;
        }
    };

    // 消费者：从队列里取数据
    auto consumer = [&queue](int id) {
        for (int i = 0; i < 5; ++i) {  // 每个消费者消费 5 个数据
            int data = 0;
            queue.wait_pop(data);  // 如果队列空了就阻塞等待
            std::cout << "Consumer " << id << " popped: " << data << std::endl;
        }
    };

    // 启动 2 个生产者线程
    std::thread p1(producer, 1);
    std::thread p2(producer, 2);

    // 启动 2 个消费者线程
    std::thread c1(consumer, 1);
    std::thread c2(consumer, 2);

    // 等待所有线程完成（因为每个线程只生产/消费 5 个数据）
    p1.join();
    p2.join();
    c1.join();
    c2.join();

    std::cout << "All threads finished." << std::endl;
    return 0;
}
```