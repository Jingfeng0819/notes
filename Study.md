# JAVA

## 基础知识

### Java vs C++

Java 和 C++ 都是面向对象的语言，都支持封装、继承和多态

##### 语言特性

- Java语言给开发人员提供了更为简洁的语法；完全面向对象，由于JVM可以安装到任何的操作系统上，所以说它的可移植性强
- Java语言中没有指针的概念，引入了真正的数组。不同于C++中利用指针实现的“伪数组”，Jave引入了真正的数组，同时将容易造成麻烦的指针从语言中去掉，这将有利于防止在C++程序中常见的因为数组操作越界等指针操作而对系统数据进行非法读写带来的不安全问题
- C++也可以在其他系统运行，但是需要不同的编码（这一点不如Java，只编写一次代码，到处运行），例如对一个数字，在windows下是大端存储，在unix中则为小端存储。Java程序一般都是生成字节码，在JVM里面运行得到结果
- Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。
- C ++同时支持方法重载和操作符重载，但是 Java 只支持方法重载（操作符重载增加了复杂性，这与 Java 最初的设计思想不符）

##### 垃圾回收

- C++用析构函数回收垃圾，写C和C++程序时要注意内存的申请和释放
- Java语言不使用指针，内存的分配和回收都是自动进行的，程序员无须考虑内存碎片的问题

##### 应用场景

- Java在桌面程序上不如C++实用，C++可以直接编译成exe文件，指针是c++的优势，可以直接对内存的操作，但同时具有危险性。（操作内存的确是一项非常危险的事情，一旦指针指向的位置发生错误，或者误删除了内存中某个地址单元存放的重要数据，后果是可想而知的）

- Java在Web 应用上具有C++ 无可比拟的优势，具有丰富多样的框架
- 对于底层程序的编程以及控制方面的编程，C++很灵活，因为有句柄的存在

### JVM vs JDK vs JRE

##### JVM

Java 虚拟机（Java Virtual Machine, JVM）是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。字节码和不同系统的 JVM 实现是 Java 语言“一次编译，随处可以运行”的关键所在。

##### JDK和JRE

JDK（Java Development Kit）是一个功能齐全的 Java 开发工具包，供开发者使用，用于创建和编译 Java 程序。它包含了 JRE（Java Runtime Environment），以及编译器 javac 和其他工具，如 javadoc（文档生成器）、jdb（调试器）、jconsole（监控工具）、javap（反编译工具）等。

JRE 是运行已编译 Java 程序所需的环境，主要包含以下两个部分：

1. **JVM** : 也就是我们上面提到的 Java 虚拟机。
2. **Java 基础类库（Class Library）**：一组标准的类库，提供常用的功能和 API（如 I/O 操作、网络通信、数据结构等）。

### 为什么说Java语言“编译与解释并存”

这是因为 Java 语言既具有编译型语言的特征，也具有解释型语言的特征。因为 Java 程序要经过先编译，后解释两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码（`.class` 文件），这种字节码必须由 Java 解释器来解释执行。

### 包装类型的缓存机制

Java 基本数据类型的包装类型的大部分都用到了缓存机制来提升性能。

两种浮点数类型的包装类 `Float`,`Double` 并没有实现缓存机制。

```java
Integer i1 = 33;
Integer i2 = 33;
System.out.println(i1 == i2);// 输出 true

Float i11 = 333f;
Float i22 = 333f;
System.out.println(i11 == i22);// 输出 false

Double i3 = 1.2;
Double i4 = 1.2;
System.out.println(i3 == i4);// 输出 false
```

### 重载和重写

##### 重载

发生在同一个类中（或者父类和子类之间），方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。

##### 重写

重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。

1. 方法名、参数列表必须相同，子类方法返回值类型应比父类方法返回值类型更小或相等，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。
2. 如果父类方法访问修饰符为 `private/final/static` 则子类就不能重写该方法，但是被 `static` 修饰的方法能够被再次声明。
3. 构造方法无法被重写

# 计算机网络

## 基础知识

### 网络模型

OSI网络模型共有七层，分别是应用层、表示层、会话岑、传输层、网络层、数据链路层以及物理层，负责职能如下：

- 应用层，负责给应用程序提供统一的接口；
- 表示层，负责把数据格式转换，压缩加密功能；
- 会话层，负责控制应用程序间的会话能力，如不同软件数据分发给不同软件；
- 传输层，负责端到端的数据传输，如TCP、UDP；
- 网络层，负责数据的IP路由、转发、分片，如不同设备间的数据转发；
- 数据链路层，负责定义数据的基本格式，如何传输，如网卡MAC 寻址；
- 物理层，负责底层传输数据，如网线；

TCP/IP网络模型共有四层，应用层，传输层，网络层和网络接口层，每一层负责的职能如下：

- 应用层，负责向用户提供一组应用程序，比如HTTP、DNS、FTP等；
- 传输层，负责端到端的同学，比如TCP、UDP等；
- 网络层，负责网络包的封装、分片、路由、转发，比如IP、ICMP等；
- 网络接口层，负责网络包在物理网络中的传输，比如网络包的封帧、MAC寻址、差错检测，以及通过网卡传输网络帧等；

网络接口层的传输单位是帧 (frame)，IP层是包 (packet)，TCP层是段 (segment)，HTTP是消息或报文 (message)。

### 键入URL到网页显示经历了什么

1. 解析URL：浏览器会解析出协议、主机、端口、路径等信息，构建一个HTTP请求（会判断是否有HTTP缓存）

2. 域名解析DNS：查询URL对应的IP地址

   域名层级类似一个树桩结构：

   - 根服务器 (.)
   - 顶级服务器 (.com)
   - 权威服务器 (server.com)

3. TCP三次握手
4. 浏览器发送HTTP/HTTPS到web服务器
5. 服务器处理并返回HTTP报文，包含请求网页以及状态码，设置的cookie等
6. 浏览器渲染界面
7. TCP四次挥手

## HTTP

### HTTP常见状态码

常见状态码：

- 1xx 提示信息，处于中间状态
- 2xx 成功，200OK 
- 3xx 重定向，资源发送变动，需要重新发请求 301：永久重定向 304 Not Modified：配合协商缓存使用
- 4xx 客户端发送报文有误 400 Bad Request：笼统错误 404 Not Found：资源不存在
- 5xx 服务端处理请求错误

### HTTP常见字段

Host字段：客户端发送请求，用来制定服务器域名

Content-Length字段：服务器返回数据，表面本次数据长度

Connection字段：客户端要求服务器使用「HTTP长链接」

Content-Type：服务器告诉客户端本次数据格式，发送的是网页，编码是UTF-8

COntent-Encoding：数据压缩方法

### GET和POST区别

##### 概念

GET是请求资源，请求参数写在URL中，不会对服务器产生影响，GET方法是安全、幂等的，GET请求会被浏览器缓存，下一次传输数据相同就会返回缓存内容，GET 产生一个TCP数据包

POST是客户端向服务器提交数据，请求参数放在请求体，PSOST方法是不安全、非幂等的，POST请求不会被浏览器缓存，POST产生两个TCP数据包，先发送header等服务端返回100后再发送body

### HTTP缓存技术

强制缓存：浏览器判断缓存没国旗，直接使用浏览器的本地缓存，决定权在浏览器

协商缓存：服务端在响应中提供了一些标识，与服务端协商后，通过协商结果判断是否使用本地缓存，返回304 Not Modified则表示不会返回资源

### HTTP与HTTPS

- HTTP是超文本传输协议，信息是明文传输。HTTPS在TCP和HTTP网络层直接加入了SSL/TLS安全协议，使得报文能够加密传输。

- HTTP默认端口80，HTTPS默认端口443

- HTTPS需要申请证书，来保证服务器身份是可信的。

### HTTPS建立连接流程

1. 客户端发起请求，向服务器发送支持的TLS版本，加密算法，生成一个随机数
2. 服务器收到请求后，向客户端发出响应，发送数字证书，确认TLS版本，加密算法，生成一个随机数
3. 客户端收到回应后，确认数字证书的真实性。从数字证书中取出服务器RSA公钥加密一个随机数并发送，双方用这三个随机数和协商的加密算法生成会话密钥（（ECDHE）会发送椭圆曲线，椭圆曲线公钥）
4. 服务器收到后，用RAS私钥揭秘出第三个随机数，计算出会话密钥，发送握手结束通知。

常用的密钥交换算法有两种：RSA算法和ECDHE（基于ECC椭圆曲线）算法

### HTTP/1.1、HTTP/2、HTTP/3演变

##### HTTP/1.1

- 长连接：支持长链接，Connect字段默认开启keep-alive
- 管道化：支持管道网络传输
- 缓存：加入了多种缓存控制头Etag
- 新增六种请求方法，如DELETE、CONNECT等

问题：服务器按请求顺序响应，响应慢有队头阻塞问题

##### HTTP/2

基于HTTPS，有安全性保障

- 头部压缩：使用HPACK算法压缩头部，消除重复请求头。
- 二进制格式：报文不像HTTP/1.1采用纯文本形式，改用二进制格式
- 并发传输：通过STREAM，多个Stream复用一条TCP连接，达到并发效果

问题：所有的Stream跑在一条TCP连接上，共享一个滑动窗口，Stream A被阻塞后，其他Stream必须等待，这是由于TCP需要保证数据完整连续，前一个数据没到达，后收到的数据存在内核缓冲区，产生队头阻塞

##### HTTP/3

改为UDP的QUIC协议

1. 无队头阻塞：当某个流丢包，只会阻塞这个流，其他流不受影响，不存在队头阻塞问题
2. 更快的连接建立：QUIC内部包含TLS，可以同时完成QUIC三次握手和TLS握手
3. 不像TCP采用四元组（源IP、源端口、目的IP、目的端口）确定一条TCP连接，采用连接ID标记通信

### HTTP/1.1优化

- 尽量避免发送HTTP请求：通过缓存技术。
- 减少HTTP请求次数
  1. 多个小资源合并成大资源再传输，减少HTTP请求次数以及头部重复传输，来减少TCP连接数量
  2. 按需访问资源，只访问当前用户看的到/用得到的资源，减少同一时间的HTTP请求次数，减少QPS

- 压缩响应资源，选择更好的压缩算法

### HTTP和RPC

- HTTP和各类RPC是TCP之上定义的应用层协议
- RPC本质上是一种调用方式，类似Thrift这种具体实现才是协议，RPC不一定基于TCP协议
- 一般对外用HTTP协议，内部集群微服务之间用RPC

### HTTP和WebSocket

- HTTP/1.1是半双工，需要服务器主动推数据到客户端
- 客户端和服务端需要频繁交互的场景需要使用WebSocket协议
- WebSocket会先利用HTTP协议加上一些请求头进行握手升级，握手成功后用WebSocket数据格式进行收发数据

## TCP

### TCP头格式

1. 序列号：在建立连接时由计算机生成的随机数作为初始值，发送一次数据就累加一次大小。用来解决网络包乱序问题
2. 确认应答号：指下一次期望收到的数据的序列号，发送端收到这个确认应答后认为在这个序号以前的数据被正常接收。用来解决丢包问题
3. 控制位：
   - ACK：为1时，确认应答字段有效，除了最初建立时的SYN包之外必须设置为1。
   - RST：为1时，表示出现异常必须强制断开连接。
   - SYN：为1时，表示希望建立连接，设定序列号初始值。
   - FIN：为1时，表示不会再用数据发送，希望断开连接，双方主席呼唤FIN为1的TCP段。

### 唯一确定一个TCP

TCP四元组可以唯一确定一个连接：源地址、目标地址、源端口、目标端口。

源地址和目标地址的字段（32位）在IP头部中，作用是通过IP协议发送报文给对方主机。

源端口和目标端口的字段（16位）在TCP头部中，作用是告诉TCP协议应该把报文发给哪个进程。

### TCP和UDP

1. 连接
   - TCP是面向连接的、可靠的、基于字节流的传输层通信协议。
   - UDP不需要连接，支持一对多，不保证可靠交付数据。
2. 控制
   - TCP有拥塞控制和流量控制，保证数据传输的安全性
   - UDP则没有，网络拥堵不影响UDP发送速率
3. 首部开销
   - TCP首部一般是20字节，如果使用「选项」字段会变长
   - UPD首部只有8个字节，开端较小
4. 传输方式
   - TCP流式传输，没有边界，但保证顺序和可靠
   - UDP一个包一个包发送，有边界，但可能会丢包乱序
5. 分片不同
   - TCP数据大于MSS（MTU取出IP头部和TCP头部，TCP数据最大长度），在传输层分片，因为TCP的超时重传机制重传整个IP分片的效率太低，进行重发以MSS为单位，不用重传所有分片
   - UDP数据大于MTU（网络包长度1500字节），在IP层分片

### TCP建立连接

##### TCP三次握手

1. 一开始，客户端和服务端处于CLOSE状态，服务的主动监听某个端口，处于LISTEN状态
2. 客户端随机初始化序号，向服务端发送一个SYN包，表示客户端希望建立连接，客户端处于SYN-SENT状态
3. 服务端收到之后，也初始化自己的序号，并把确认序列号填入SYN序列号 + 1，发送SYN、ACK包，服务端处于SYN-RCVD状态
4. 客户端收到后，发送ACK包，序列号会+1，发送给客户端，也可以携带数据，之后客户端处于已连接状态
5. 服务器接收到ACK报文后，也进入已连接状态

##### 为什么是三次握手

1. 避免历史连接：在网络拥堵的情况，一个旧的SYN报文比新报文更早到达服务端，服务端发送错误的确认号给客户端，客户端收到后发现不对，回RST报文，等待新的SYN抵达服务端就可以正确的完成三次握手。在两次握手的情况下，客户端无法阻止历史连接，造成资源浪费。
2. 同步初始序列号：客户端发送SYN，服务端回一个ACK代表客户端报文被接收，服务端发送SYN也需要客户端回应ACK，这样一来一回才能确保双方初始序列号被可靠同步。
3. 避免资源浪费：当客户端发送的SYN报文网络阻塞，客户端没有接收到ACK会重新发送SYN，如果没第三次握手，服务端会建立多个冗余的无效连接，会造成资源浪费

##### 为什么初始化序列号要求不一样

- 为了防止历史报文被下一个相同四元组连接所接收：客户端发送数据包被网络阻塞，触发超时重传，服务端重启，重建连接，完成相同四元组连接，上一个数据包抵达服务端，正常接收后会数据错乱

##### 握手失败怎么办

SYN报文没收到ACK会触发超时重传机制

##### SYN攻击

攻击者发送不同IP地址的SYN报文，服务端不断发送SYN-ACK报文，会占满半连接队列（SYN队列），无法为正常用户服务。

解决方法：开启syncookies

##### 半连接队列和全连接队列

- 半连接队列（SYN队列）：服务端收到第一次握手，会将socket加入到队列，都处于SYN_RECv状态。是哈希表，为了查询方便。半连接队列满了，可能是收到SYN攻击，可以开启synccookies，绕开半连接队列。
- 全连接队列（ACCEPT队列）：服务端收到第三次握手，将半连接队列的socket取出，放进全连接队列，都处于ESTABLISHED状态，等待服务端执行accept()后取出。全连接队列满了，会放弃第三次握手。

### TCP断开连接

##### 四次挥手过程

1. 客户端发送FIN 报文，客户端进入FIN_WAIT_1状态
2. 服务端收到后，发送ACK报文，服务端进入CLOSE_WAIT状态
3. 客户端接收到ACK，进入FIN_WAIT_2状态
4. 服务端处理完数据，发送FIN报文，服务端进入LAST_ACK状态
5. 客户端收到后，发送ACK报文，进入TIME_WAIT状态
6. 服务端收到ACK后，进入CLOSE
7. 客户端经过2MSL后，进入CLOSE

##### 为什么是四次挥手

客户端发送FIN表示客户端不再发送数据，服务端可能还有数据处理，服务端发送FIN才表示同意关闭连接，一般FIN和ACK会分开发送，所以是四次。如果开启TCP延迟确认机制，当没有响应数据发送是，ACK会延迟一段时间，ACK和FIN会合并传输，就是三次挥手，

##### 挥手丢失怎么办

- 第一次挥手丢失：客户端超时重传失败后，进入CLOSE状态，断开连接
- 第二次挥手丢失：客户端超时重传失败后，进入CLOSE状态，断开连接
- 第三次挥手丢失：服务端超时重传失败后，进入CLOSE状态，断开连接，客户端FIN_WAIT_2时间60秒超时，断开连接
- 第四次挥手丢失：服务端超时重传失败后，进入CLOSE状态，客户端处于TIME_WAIT，超过2MSL60秒后，断开连接

##### TIME_WAIT状态

TIME_WAIT等待时间2MSL，MSL是报文最大生存时间，客户端接收到FIN发送ACK开始，服务端超时重传FIN，一来一回两个MSL

原因：

- 防止历史连接数据，被后面相同四元组的连接接收，让两个方向上的历史数据包都被丢弃。
- 保证被动关闭的一方能正确关闭。

### TCP重传机制

- 超时重传：在超时重传时间（略大于RTT）内没有收到ACK，发送方触发重传，超时间隔加倍
- 快速重传：接收方连续收到相同ACK，会重传丢失的报文

### 滑动窗口和流量控制

- TCP头有一个「窗口」字段，接受端告诉发送端自己还有多少缓冲区可以接受数据
- 流量控制是确保发送方不要发送超过接收方缓冲区容量的数据，会动态调整窗口大小

### 拥塞控制

拥塞控制是在网络出现拥塞时动态调整数据传输速率，防止网络过载

1. 慢启动：TCP发送端会以较小的发送窗口开始传输数据，以指数级增加发送窗口的大小
2. 拥塞避免：达到慢启动阈值后，进入拥塞避免状态，以线性增加发送窗口的大小，避免网络堵塞
3. 快速重传：当网络拥塞，发送方连续收到相同的确认，触发快速重传，不必等待超时重传
4. 快速恢复，发送方将慢启动阈值设为当前窗口的一半，拥塞窗口设置为慢启动阈值加上还未重传的数据的大小。

### 如何优化TCP

##### 三次握手

- 客户端优化：根据网络稳定性和服务器的繁忙程度修改SYN的重传次数，比如内网通信调低重试次数，将错误暴露给应用程序
- 服务端优化：调整半连接队列（哈希表）和全连接队列（链表）的长度，调整SYN-ACK重传次数
- 绕过三次握手：开启TCP Fast Open，第一次发起请求的时候需要三次握手，后续通过Fast Open Cookie优化

##### 四次挥手

- 主动方：调整FIN报文重传次数，调整FIN_WAIT2状态的时间，调整TIME_WAIT状态上限个数防止占用太多资源
- 被动方：调整FIN报文重传次数

### TCP字节流和粘包问题

TCP是以字节流的方式传输数据，当数据大于MSS（最大报文段长度，一般为1460bit），会分成多个报文段。发送端会将需要发送的数据发到缓冲区，缓冲区满了以后再发送到接收方。当两个消息的某一部分合并到同一个TCP报文，会产生粘包问题。

TCP有一个negal算法，多个小数据包会组合成一个大包发送，这就会产生粘包问题。

处理粘包问题：

- 发送方：关闭negal算法

- 接收方，只能通过应用层处理。

  a. 格式化数据：每条数据有固定的开始符结束符 

  b. 自定义消息结构，将数据长度和数据一起发送

### TCP Keepalive和HTTP Keepalive

- TCP保活机制由「内核」实现，可以在双方没有数据交互的情况下，通过探测报文，来确定对方的TCP连接是否存活
- HTTP长连接由「应用程序」实现，同一个TCP连接发送接收多个HTTP请求，减少了HTTP短连接带来的多次TCP建立和释放的开销

### QUIC协议实现可靠传输

- 可靠传输：有单向递增的Packet Number，配合Stream ID （类似HTTP/2）+ Offset（类似Seq序号）字段信息支持乱序确认而不允许数据包的组装，不必像TCP按顺序确认应答ACK
- 队头阻塞：一条QUIC连接发送多个HTTP请求（Stream），每个Stream都有一个滑动窗口，互相独立
- 流量控制：每个Stream流有独立的滑动窗口，做单独的流量控制，所有Stram流加起来的总字节数小于缓冲区大小。

### TCP细节问题

##### SYN报文什么时候会被丢弃

- 半连接队列满了：当服务器收到SYN攻击，TCP半连接队列满了，后面来的SYN包都被丢弃，如果开启了syncookies功能，即使半连接队列满了，也不会丢弃SYN包
- 全连接队列满了：当服务端并发处理大量请求，TCP全连接队列满了，后续连接就会被丢弃

##### 已建立连接的TCP，收到SYN发生什么

- SYN报文端口号不同：通过新的三次握手建立连接。如果旧连接服务端发送了数据包，客户端由于已经关闭，发送RST报文，如果未发送数据包，通过保活机制释放连接。
- SYN报文端口号相同：客户端发送SYN报文的序列号是乱序，服务端回复正确的ACK，客户端发现确认好部署自己想要的，发送RST报文。

##### 四次挥手收到乱序FIN怎么办

在FIN_WAIT_2状态时，如果收到乱序的FIN报文，会被加入到乱序队列，并不会进入到TIME_WAIT，再收到前面被网络延迟的数据包时，会从乱序队列找可用数据，再进入TIME_WAIT状态。

##### 在TIME_WAIT状态的TCP连接，收到SYN会发生什么

- 合法SYN：会重启四元组连接，跳过@MSL转变为SYN_RECV状态，开始第二次握手
- 非法SYN：会再回复一个第四次挥手的ACK报文，客户端收到后发现不是自己期望的确认号，发送RST报文

##### TCP连接，一端断电和进程崩溃的区别

- 主机崩溃：如果服务端会发送数据，超时重传一定次数后，断开TCP连接。如果不发送数据，通过TCP保活机制释放连接。
- 进程崩溃：内核会发送FIN报文，与服务端四次挥手

##### 拔掉网线后，TCP连接还存在吗

- 有数据传输：1. 在超时重传次数没有达到上限前重连，能正常存在 2. 超时重传上限，断开TCP连接，客户端重连后发送数据服务端回复RST报文
- 无数据传输：1. 如果开启TCP保活，在探测期间插回重连之后，能正常存在 2. 未开启则一直存在

##### TLS同时进行三次握手

当满足一下条件，TLS1.3版本会话恢复机制，重连只需0RTT

- 开启TCP Fast Open功能，TLS版本为1.3
- 客户端与服务端已经完成过一次通信

##### TCP协议缺陷

- TCP队头阻塞问题，TCP是字节流协议，保证收到的字节顺序是完整有序的，前一个数据没到达，后收到的数据存在内核缓冲区，产生队头阻塞
- TCP建立连接的延迟：TCP三次握手和TLS四次握手后才能进行数据传输，还有TCP慢启动的减速过程，比如HTTP 1.0/1.1、HTTP/2、HTTPS
- IP地址变更后需要重新建立连接

##### TCP和UDP公用一个端口

TCP和UDP在内核是两个独立的软件模块实现，主机通过协议号确定传给哪个模块，因此相互独立不受影响

##### 服务端没有listen，客户端发起连接会发生什么

客户端对服务端发起SYN报文，服务端回RST报文

##### 用了TCP一定不会丢吗

- 建立连接丢包：半连接队列和全连接队列丢包，连接失败
- 流量控制丢包：当数据发送过快，流量控制窗口溢出
- 接收缓冲区丢包：接收缓冲区满了，会变成零窗口，这时候如果发送端再发数据，会丢包

## IP

### 基本认识

IP处在网络层，作用是在复杂的网络环境中将数据包发送给目标主机（非直连，直连为数据链路层MAC），源IP地址和目标IP地址在传输过程不会变化（没使用NAT网络），只有源MAC地址和目标MAC地址一直在变化。、

### IP地址分类

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/7.jpg" alt="IP 地址分类" style="zoom:50%;" />

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/8.jpg" alt="img" style="zoom:50%;" />

计算最大主机个数为2^8 - 2=254

- 主机号全1指定某个网络下的所有主机，用于广播，在同一个链路互相连接的主机之间发送数据

- 主机号为0指定某个网络

### CIDR

无分类地址，表示形式 a. b. c. d/x, /x表示前x位上网络号

### IP分片与重组

以太网的最大传输单元MTU是1500字节，当IP数据包大小大于MTU，IP数据包会被分片，一旦某个分片丢失，会造成整个IP数据包作废。

### IP相关协议

##### DNS

DNS可以将域名网址自动转换为具体的IP地址，客户端发出一个DNS请求，发给本地DNS服务器，如果缓存中能找到就直接返回IP地址。如果没有，则按照根服务器、顶级域服务器、权威服务器的顺序查找IP地址。

| 场景         | 协议 | 原因              | 性能特点       |
| ------------ | ---- | ----------------- | -------------- |
| **标准查询** | UDP  | 快速、轻量        | 低延迟，高吞吐 |
| **大响应**   | TCP  | 突破 512 字节限制 | 可靠传输       |
| **区域传输** | TCP  | 大量数据传输      | 保证完整性     |

##### CDN

CDN（Content Delivery Network，内容分发网络） 是一种分布式服务器网络，通过将内容缓存到全球多个节点，使用户从最近的服务器获取数据，从而加速访问、降低延迟，并减轻源站压力。

当用户请求资源时，CDN的DNS解析会返回用户最近的CDN节点的IP地址，CDN会检查是否已经缓存，该资源若CDN节点已缓存资源，直接返回。若未缓存，回源服务器拉取并缓存

##### ARP

ARP通过ARP请求和ARP响应两种类型的包确定MAC地址

- 主机通过广播发送ARP请求，这个包中包含了想要知道的MAC地址的主机IP地址
- 同一个链路的所有设备收到ARP请求时，回去拆开ARP请求包里的内容，如果IP地址和自己的IP地址一致，那么就会将自己的MAC地址塞入ARP响应包返回给主机

RARP是已知MAC地址求IP地址

##### DHCP

DHCP用来动态获取IP地址，有DHCP中继代理，对不同网段的IP地址分配也可以由一个DHCP服务器统一管理

- 客户端发起DHCP发送报文，传递给链路层，链路层广播到所有网络设备中
- DHCP服务器接收到报文，响应DHCP提供报文，提供可租约的IP地址
- 客户端收到后，从中选择一个服务器发送DHCP请求报文进行响应
- 最后服务端用DHCP ACK报文进行应答
- 客户端收到DHCP ACK后，就可以在租用期内使用DHCP服务器分配的IP地址

##### NAT

NAT网络地址转换，把同一个公司的主机对外部通信，把私有地址转换为公有地址

##### ICMP

互联网控制报文协议，主要功能包括：确认IP包是否成功送达、报告发送过程中IP包被废弃的原因和改善网络设置等。ping命令基于ICMP协议实现

ICMP类型：1. 用于诊断等查询消息，也就是查询报文类型 2. 通知出错原因的错误消息，也就是差错报文类型

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/ping/6.jpg" alt="常见的 ICMP 类型" style="zoom:50%;" />

### 断网了还能ping通127.0.0.1吗

127.0.0.1是回环地址，有网的情况下是通过网卡发送数据，当发现目标IP是回环地址，会选择lo0假网卡，在快出网卡前，将数据插入到一个链表后通过软中断通知接受数据，不出网络，所以断网也能ping通。

# 操作系统

### 常用命令

ls：列出文件和子目录

cd：切换目录

pwd：显示当前目录路径

cat：显示文件内容

vi：编辑文件

ps：列出运行中的进程

grep：查找文件符合条件的字符串

kill：终止进程

ifconfig：查看ip地址

ping：测试网络连接

### 虚拟内存分段和分页

操作系统将不同进程的虚拟地址和不同内存的物理地址映射起来

分段：

- 虚拟地址由段号和段内偏移量组成。
- 地址空间被划分为不同逻辑段，如代码段、数据段等
- 段长度可以动态变化，产生多个不连续的小物理内存，会出现外部内存碎片的问题
- 交换时需要找到更大的空闲内存来加载段，内存交换效率低

分页：

- 虚拟地址由页号和页内偏移组成。
- 地址空间被划分为固定大小的页面
- 页面长度固定，会导致页面内部有未使用空间，出现内部内存碎片的问题。

### 内存满了会发生什么

内核在分配物理内存的时候，如果空闲物理内存不够，那么就会进行内存回收的工作：

- 后台内存回收：幻想kswapd内核线程挥手内存，异步的，不会阻塞进程的执行
- 直接内存回收：如果后台回收跟不上申请速度，就会开始直接回收，同步的，会阻塞进程执行

可被回收的内存类型有文件页和匿名页，基于LRU方法，优先回收不常访问的内存。

swap机制是把一块磁盘空间或者本地文件，当成内存使用：

- 换出（Swap Out），把进程暂时不用的内存数据存到磁盘中，并释放这些数据占用的内存
- 换入（Swap In），在进程再次访问这些内存时，把他们从磁盘读到内存中

当同一页面频繁换入换出，叫做抖动，原因是进程频繁访问的页面数目高于可用的物理块数目（分配给进程的物理块不够）

### 中断和异常

中断和异常都会导致处理器暂停当前正在执行的任务，并转向一个特定的处理程序。

- 中断是由计算机系统外部事件触发，通常与硬件设备相关，包括时钟中断、I/O设备中断等。
- 异常是由计算机系统内部事件触发，通过与正在执行的程序或指令有关；

### 用户态和内核态

用户态和内核态是操作系统为了保护系统资源和实现权限控制而设计的两种CPU运行类别，可以控制进程或程序对计算机硬件资源的访问权限和操作范围。当系统调用、中断、异常时会发生内核态和用户态切换，需要操作系统提供服务。

- 用户态：在用户态下，进程或程序只能访问受限的资源和执行受限的指令集，不能之间访问操作系统核心部分和硬件资源。
- 内核态：操作系统的权限级别，允许进程或程序执行特权指令和访问操作系统的核心部分。

### 进程和线程

进程是系统进行资源分配基本单位。线程是CPU调度的最小单位。一个进程至少有一个进程，这些线程共享一块内存。

资源开销：

- 进程有独立的内存空间，创建和销毁进程的开销较大。进程间切换需要保存整个进程状态，上下文切换开销大
- 线程共享内存空间，创建和销毁线程的开销较小。线程间切换只需要保存少量的寄存器和栈内容，不需要切换页表，上下文切换开销较小

通信和同步：

- 进程间相互隔离，需要用管道、消息队列等方式通信
- 线程共享内存空间，可以直接访问共享数据

安全性：

- 进程相互隔离，一个进程崩溃不会直接影响其他进程稳定性
- 线程共享内存空间，一个线程错误影响整个进程稳定性

协程：用户态的轻量级线程，线程内部调度的基本单位，只在用户态调用，同一时间只能执行一个协程

### 进程的状态

- 运行状态：进程占用CPU正在运行的状态
- 就绪状态：进程获得除CPU外所有资源，等待进入运行状态
- 阻塞状态：进程等待某一事件发生而暂时停止运行
- 创建状态：进程申请一个空白进程控制块（PCB），进行资源分配，正在被创建的状态
- 结束状态：进程正在从系统消失的状态，无法再执行
- 挂起状态：阻塞的进程被换出到硬盘，阻塞挂起（等待事件发生）和就绪挂起（进入内存立刻运行）

### 进程间通信方式

- 管道：半双工通信方式，数据单向流动，只能父子进程使用
- 命名管道：允许无亲缘关系进程通信
- 信号量：控制多个进程对共享资源的访问，一种同步手段，使用P、V操作
- 消息队列：消息的链表
- 共享内存：最快的通信方式，一般配合信号量使用，实现进程间同步和通信
- socket套接字：客户端和服务器之间通信

### 进程调度算法

1. 先来先服务：从就绪队列选择最先进入队列的进程，一直运行直到退出或被阻塞，才会继续选择下一个，不利于短作业，适合CPU繁忙型系统
2. 最短作业优先：选择运行事件最短的进程来运行，对长作业不利，容易造成长作业长期不被运行
3. 高响应比优先调度算法：计算响应优先级，响应优先级最高的投入运行（优先权 = 等待时间 + 要求服务时间 /要求服务时间），理想型调度算法，要求服务时间不可预知
4. 时间片轮转：每个进程分配一个时间段20ms～50ms，用完或阻塞就分配给另一个进程
5. 多级队列：多个队列每个队列设置不同大小时间片，每个队列优先权不同，新进程放在第一级队列末尾，没运行完成转入第二级队列末尾，上一个队列没有进程才会调度到当前队列。

### 僵尸进程和孤儿进程

- 僵尸进程：进程使用fork创建子进程，如果子进程退出，父进程没有调用wait获取子进程状态信息，那么子进程的进程描述符仍然存在。
- 孤儿进程：一个父进程退出，而子进程还在运行，那么子进程为孤儿进程，被init进程所收养，并对他们完成状态手机工作。

### 线程同步方式

1. 互斥锁：允许一个线程访问共享资源
2. 条件变量：用于线程间通信，线程等待某个条件满足，其他线程发送信号通知等待线程。
3. 读写锁：多个线程读资源，一个线程写资源
4. 信号量：控制多个线程多共享资源访问

### 锁

基础的锁

- 互斥锁：互斥访问共享资源，同一时间只有一个线程访问被保护资源
- 自旋锁：线程在尝试获取锁会不断轮询，直到锁释放
- 读写锁：多个线程同时读共享资源，只允许一个线程写操作
- 悲观锁：认为同时修改共享资源概率高，所以访问共享资源要先上锁
- 乐观锁：先修改共享资源，如果出现同时修改的情况再放弃操作

### 死锁

- 互斥条件：多个线程不能同时使用同一个资源
- 保持并等待条件：一个线程因为请求资源而阻塞时，不会释放自己的资源
- 不可剥夺条件：资源在自己使用完之前不能被其他线程获取
- 环路等待条件：每个线程都在等待下一个进程占用的资源，形成循环等待资源的环形链

破坏死锁：

- 破坏保持并等待条件：一次性申请所有资源
- 破坏不可剥夺条件：申请不到资源时，主动释放资源
- 破坏循环等待条件：所有进程按照相同顺序请求资源

### 阻塞与非阻塞I/O

- 阻塞I/O：当程序执行read，线程被阻塞，一直等到内核数据准备好，等待的是数据准备好和数据拷贝这两个过程
- 非阻塞I/O：数据未准备好立即返回，可以继续往下执行，应用程序不断轮询，直到数据准备好。
- I/O多路复用：通过I/O事件分发，当内核数据准备好，再通知应用程序，用户可以在一个线程同时处理多个socket的I/O请求/

阻塞I/O、非阻塞I/O、基于非阻塞的多路复用都是同步调用，数据从内核空间拷贝到应用程序空间都需要等待，这个过程是同步的。

异步I/O是aio_read，数据准备好会自动拷贝到应用进程。

### PageCache

文件传输过程第一步是把磁盘文件数据拷贝到内核缓冲区，这个内核缓冲区就是磁盘高速缓存（PageCache）。

程序运行的时候具有「局部性」，用PageCache来缓存最近被访问的数据。PageCache使用了预读功能，比如read只读32KB的字节，内核会把后面32～64KB的字节也读到PageCache。

针对大文件传输，PageCache会不起作用，PageCache会很快被大文件展满，其他的热点小文件就无法被充分使用，性能下降。

### I/O多路复用

- select/poll：使用线性结构存储Socket集合，需要遍历文件描述符集合来找到Socket，时间复杂度为O(n)，需要在用户态和内核态之间拷贝文件描述符集合。只支持水平触发
  - selece：将已知的Socket都放进一个文件描述符集合，再调用select函数拷贝到内核，通过遍历文件描述符方式检测是否有事件发生，再把整个文件描述符拷贝回用户态，用户态再通过遍历找到Socket，才进行处理。使用BitsMap表示文件描述符集合，所支持的个数有限。
  - poll：不再用BitsMap来存储所关注的文件描述符，改为动态数组，突破了描述符个数限制。

- epoll：linux独有，支持水平触发和边缘触发。
  - 在内核使用红黑树来跟踪带检测的文件描述符，只需要传入带检测的socket，减少了大量内核态和用户态的数据拷贝
  - 采用事件驱动机制，内核维护文件描述符列表，只有文件描述符就绪才会通知应用程序，不需要应用程序去遍历

### Reactor模式

I/O多路复用监听事件，收到事件后，根据事件类型分配给某个进程/线程。

Rector模式由Reactor和处理资源池组成，Reactor负责监听和分发，处理资源池负责处理事件

### 一致性哈希

轮询策略只能适用于节点的数据都是相同的场景，不适合分布式系统。

哈希算法虽然能建立数据和节点的映射关系，但是节点数量变化时，最坏情况下所有数据都要前一，不适用节点数量变化场景。

一致性哈希是，对2^ 32取模，将存储节点和数据都映射到一个首尾相连的哈希环上，如果增加或者移除一个节点，只影响该节点在哈希环顺时针相邻的后继节点。

对一个真实节点做多个虚拟节点，映射到哈希环，解决不能均匀分布节点的问题。

# 数据库

基于TiDB打造的分布式关系型数据库

### 索引分类

##### 按数据结构分类

- B+ Tree索引：
- HASH索引：

##### 按字段特性分类

- 主键索引：主键索引是主键字段上的索引，索引列不能有空值
- 唯一索引：建立在UNIQUE字段上的索引，索引列值唯一，单可以有空值
- 普通索引：普通字段的索引

##### 按物理存储

- 聚簇索引：放的是实际数据
- 二级索引：B+树叶子节点放的是主键值

### 索引

##### 索引下推

在联合索引遍历过程中，对联合索引中包含的字段先做判断，直接过滤，减少回表次数

##### 最左匹配

查询应该canoe索引最左边的列开始，不能跳过中间的列，不能使用范围查询，如（<, >）

### 为什么要采用B+树

- B+树非叶子节点不存实际数据，只存索引，数据了相同的情况下，相对于存索引和数据的B树，非叶子节点能存更多索引，B+树更加矮胖，查询叶子节点的磁盘I/O次数更少
- B+树有大量冗余节点，B+树插入、删除的效率都更高，不会像B树一样发生复杂的树变化
- B+树叶子节点之间用双链表连接，有利于范围查询

### 事务ACID四大特性

- 原子性：事务的所有操作要么全部成功，要么全部失败回滚（undo log回滚日志）
- 一致性：事务在执行前后，数据库从一个一致性状态转变到另一个一致性状态
- 隔离性：一个事务的执行不会影响其他事务的执行（MVCC或者锁）
- 持久性：事务处理结束后，对数据的修改是永久性的，系统故障也不会丢失（redo log重做日志）

### 数据库三大范式

- 第一范式：字段不可分，即原子性，字段不能再分
- 第二范式：有主键，非主键字段依赖主键
- 第三范式：非主键字段不能相互依赖，每列都与主键有直接关系

### 事务隔离级别

- 读未提交：允许事务读取另一个事务未提交的数据修改
- 读已提交：事务只能读取已经提交的数据
- 可重复读：事务执行期间，多次读取同一数据会得到相同结果，即其他事务对数据修改不可见
- 序列化：事务之间的并发执行效果和串行效果相同

读已提交和可重复读通过Read View实现，读已提交是在每个语句执行前生成一个Read View，可重复读是启动事务时生成一个Read View

Read View在MVCC（多版本并发控制）中使用，如果一个事务去访问记录，事务id小于min事务id，可见，大于max事务id，不可见，在min和max之间，在事务id列表中，表示依旧活跃，所以不可见，不在id列表中，表示已被提交，所以可见。

### 锁种类

- 全局锁：对整个数据库加锁，全库逻辑备份场景
- 表级锁：
  - 表锁：每次操作锁住整张表
  - 元数据锁（MDL）：不需要显式使用，对一张表CRUD加读锁，表结构变更加写锁
  - 意向锁：一个事务在未来可能会请求对资源的锁定

- 行级锁：
  - Record Lock：记录锁，把一条记录锁上，记录锁分为排他锁和共享锁
  - Gap Lock：间隙锁，锁定一个范围，用于可重复读的级别，解决可重复读级别下的幻读
  - Next-Key Lock：临键锁，锁定一个范围，锁定记录本身

### 日志

- undo log（回滚日志）：保证了原子性。实现MVCC时，如果对事务不可见，就会在undo log版本里找到可见的记录。
- redo log（物理日志）：保证了持久性。记录某个数据页做了什么修改，事务提交时需要先将redo log持久化到磁盘，当系统崩溃，虽然脏页数据没持久化，但redo log已经持久化，重启后可以恢复到最新状态。写入redo log的方式用了追加操作，是顺序写，写入数据是随机写，速度快了很多。
- bin log：记录所有数据库表结构变更和表数据修改，是循环谢，日志空间固定，全部写满就从头开始，用于备份恢复，主从复制

### 两阶段提交

1. prepare阶段：写入redo log，然后持久化到磁盘
2. commit状态：写入到binlog，持久化到磁盘，将redo log状态设置为commit，binlog写盘成功，就算redo log状态还是prepare也没关系
3. 当binlog内部没有id，则证明binlog还没刷盘，事务回滚，当binlog内部有id，则提交事务

### 慢查询优化

- 对搜索字段建索引
- 垂直分表
- 使用复合索引并遵循最左匹配
- 不使用select *
- 不在where条件字段上使用函数，这会导致索引失效而全盘扫描
- 尽量避免使用!=或not in 或<>等否定符号
- 使用覆盖索引可以回避回表操作

# 设计模式

### 单例模式

一个类只有一个实例，并提供一个全局访问点来访问创建模式。

1. 一个私有构造函数（确保只能单例类自己创造实力）
2. 一个私有静态变量（确保只有一个实例）
3. 一个共有静态函数（给使用者提供调用方法）

### 策略模式

定义一系列算法，把他们单独封装起来，可以相互替换，不同策略引起不同行为。

1. 定义一个策略接口，声明算法的抽象方法
2. 创建具体策略类，实现策略接口，封装具体的算法
3. 创建环境类，包含对策略接口的引用，以及设置具体策略的方法
4. 在客户端创建环境类对象，调用其方法来执行具体算法

# Redis

### redis常见数据结构以及使用场景

- String：简单的key-value类型，value不仅是string，也可以是数字，
- Hash：string类型的field和value的映射表，hash适合用于存储对象，后续操作时，可以仅仅修改这个对象中某个字段的值，比如存储用户信息
- List：实现为双向链表，支持反向查找和遍历，比如关注列表、消息列表等
- Set：与list类似，但是set可以自动去重，访客列表等

### 为什么需要Redis

- 高性能：直接操作内存，访问速度快
- 高并发：直接操作缓存能承受请求远超访问数据库，一些高热点请求可以转移到缓存中
- 支持事物：Redis操作都是原子性

### 缓存雪崩、缓存穿透、缓存击穿

**缓存雪崩**

同一时间大面积的失效，后面的请求都会落到数据库上，造成数据库段时间内承受大量请求

**缓存穿透**

查找缓存和数据库中不存在的数据，这样每个查询都会去请求数据库，造成缓存穿透

1. 布隆过滤器：将所有可能存在的数据哈希到一个足够大的bitmap中，一般用于在大数据量大集合中判定某元素是否存在 ，适用于数据相对固定且实时性较低
2. 缓存空对象：当存储层不命中后，即使返回的空对象也缓存起来，同时设置一个过期时间，适用于数据频繁变化且实时性较高

**缓存击穿**

一个key非常热点，并发量很大，在这个key失效的瞬间，持续的高并发就穿透缓存，打到数据库

### 如何保持缓存与数据库双写的数据一致性

一般来说将读请求和写请求串行化。经典的缓存+数据库读写模式：

- 读的时候先读缓存，缓存没有读数据库，取出数据后放入缓存，同时返回响应
- 更新的时候，先更新数据库，再删除缓存，这样读的时候就会发现缓存中没有数据而直接去数据库中拿数据

### 为什么会出现数据不一致

主从同步、读写分离的情况下，读从库产生脏数据，A写了主库，B读缓存因为被A淘汰，读从库，此时还未主从同步，读出脏数据量。

# mafka

### mafka消费幂等性

1. 简单的唯一键去重判断，并发量不高的话可以解决问题，但是如果重复的消息在代码执行结束前到达，那就会穿透检查的挡板，最后导致重复的消息消费逻辑进入非幂等的业务代码，引发重复消费的问题
2. 开启事务把select改为select for update悲观锁，但是并发量会下降

### mq堆积

先根据告警去查，看看当前业务哪里消息堆积了，再看一下上游的流量和消费速度，是不是因为定时任务，看一下业务代码mq延时是不是符合预期，临时动态扩容一下。

# 海量数据处理

### 从大量URL中找出相同URL

- 分治：把一个文件中的URL进行哈希取余，分到多个小文件中，这样所有相同URL都在对应小文件中
- 前缀树：一般而言，URL的前面几个字符相同，这个时候适合使用字典树提高查询效率

### 大量数据找出高频词

分治，进行哈希取余，得到很多小文件，统计每个小文件出现的高频词，使用hashmap，最后使用小顶堆找出频数最高的100个

### 在大量数据中找到不重复整数

- 分治法：先将2.5亿个数分到多个小文件，用HashSet/HashMap找出小文件中不重复的整数，再合并每个子结果
- 位图法：用一个或多个bit来标记某个元素对应的值

### 在大量数据中判断一个数是否存在

- 分治法：与前面类似
- 位图法：先读取数据，将对应的bit设置为1，读取要查询的数所对应的bit位是否位1

### 毒药毒白鼠问题

1. 用10位二进制表示每个瓶子编号
2. 用每个瓶子的二进制表示对应的每一位决定哪只小白鼠要喝那瓶水
3. 观察哪些小白鼠死了，根据死亡的小白鼠形成一个新的10位二进制，就是有毒的瓶子编号
4. 最多可以检测2^ （小鼠个数）的瓶子

### 查询最热门的查询串

- 分治法：进行哈希取余，找出每个小文件最热门，再用小顶堆找出最热门
- 前缀树：

### 统计不同电话号码的个数

位图法：8位电话表示号码个数为10^8个，申请一个长度1亿的位图，遍历所有电话号码，把对应的位置置1，统计bit值为1的数量

### 5亿个数中找出中位数

- 双堆法：一个大顶堆一个小顶堆，大顶堆最大的数小于等于小顶堆最小的数，保证两个堆堆元素个数差不超过1，总数为偶数就是堆顶平均值，奇数就是较大的堆堆堆顶
- 分治法：对于读取到的数字，读取二进制最高位，区分出0和1的两部分，这时候就能确定是在f0的还是在f1中，再从对应的二进制次高位将文件一分为二，直到能被加载到内存中

### 找出排名前500的数

有20个数组，每个数组500个数，并且有序排列

首先建立大顶堆，堆大小为数组个数，把每个数组最大的值存到堆中，紧接着删除堆顶元素，保存到结果数组中，再向大顶堆插入删除数组的下一个元素，直到删除完第500个元素，也就找到了最大的前500

# C++

## 基础语法

### C++和Java

Java 和 C++ 都是面向对象的语言，都支持封装、继承和多态

##### 语言特性

- Java语言给开发人员提供了更为简洁的语法；完全面向对象，由于JVM可以安装到任何的操作系统上，所以说它的可移植性强
- Java语言中没有指针的概念，引入了真正的数组。不同于C++中利用指针实现的“伪数组”，Jave引入了真正的数组，同时将容易造成麻烦的指针从语言中去掉，这将有利于防止在C++程序中常见的因为数组操作越界等指针操作而对系统数据进行非法读写带来的不安全问题
- C++也可以在其他系统运行，但是需要不同的编码（这一点不如Java，只编写一次代码，到处运行），例如对一个数字，在windows下是大端存储，在unix中则为小端存储。Java程序一般都是生成字节码，在JVM里面运行得到结果
- Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。
- C ++同时支持方法重载和操作符重载，但是 Java 只支持方法重载（操作符重载增加了复杂性，这与 Java 最初的设计思想不符）

##### 垃圾回收

- C++用析构函数回收垃圾，写C和C++程序时要注意内存的申请和释放
- Java语言不使用指针，内存的分配和回收都是自动进行的，程序员无须考虑内存碎片的问题

##### 应用场景

- Java在桌面程序上不如C++实用，C++可以直接编译成exe文件，指针是c++的优势，可以直接对内存的操作，但同时具有危险性。（操作内存的确是一项非常危险的事情，一旦指针指向的位置发生错误，或者误删除了内存中某个地址单元存放的重要数据，后果是可想而知的）

- Java在Web 应用上具有C++ 无可比拟的优势，具有丰富多样的框架
- 对于底层程序的编程以及控制方面的编程，C++很灵活，因为有句柄的存在

### 为什么C++没有垃圾回收

- 实现垃圾回收会带来额外的空间和时间开销，需要开辟一个空间保存指针的引用计数，然后开辟一个线程在空闲的时候释放内存
- 垃圾回收会使得C++不适合进行很多底层操作

### 智能指针

- Shared_ptr：共享指针，采用引用计数，允许多个智能指针指向同一个对象，每当多一个指针指向该对象，引用计数+1，当计数为0时会自动释放动态分配的资源
- unique_ptr：独享指针，总是拥有他所指向的资源，转移一个unique_ptr将会把所有权全部从源指针转移给目标指针，源指针被置空
- weak_ptr：弱引用，如果循环引用，那么两个指针指向的内存都无法释放，需要使用weak_ptr，为了配合shared_ptr使用，指向一个shared_ptr对象而不影响所指对象的生命周期，只引用不计数

### 左值引用与右值引用

![image-20250721205017153](/Users/haoy/Library/Application Support/typora-user-images/image-20250721205017153.png)

### vector与list

- vector和数组类似，有一段连续空间，并且起始地址不变，查看的时间复杂度为o(1)，插入删除1️⃣内存块的拷贝，时间复杂度为o(n)
- list由双向链表实现，内存空间不连续，只能通过指针访问，查看的时间复杂度为o(n)，但由于链表的特点，能高效的插入删除

### 常见数据结构

| 数据结构                | 访问/查找最值 | 搜索                  | 插入                  | 删除                  | 空间复杂度 | 备注                         |
| ----------------------- | ------------- | --------------------- | --------------------- | --------------------- | ---------- | ---------------------------- |
| **数组 (Array)**        | O(1)          | O(n)                  | O(n)                  | O(n)                  | O(n)       | 随机访问，插入删除需移动元素 |
| **动态数组 (Vector)**   | O(1)          | O(n)                  | O(1)                  | O(n)                  | O(n)       | 末尾插入为O(1)               |
| **链表 (Linked List)**  | O(n)          | O(n)                  | O(1)                  | O(1)                  | O(n)       | 已知位置时插入删除为O(1)     |
| **双向链表**            | O(n)          | O(n)                  | O(1)                  | O(1)                  | O(n)       | 支持双向遍历                 |
| **栈 (Stack)**          | O(1)栈顶      | -                     | O(1)                  | O(1)                  | O(n)       | LIFO，只能操作栈顶           |
| **队列 (Queue)**        | O(1)队首/队尾 | -                     | O(1)                  | O(1)                  | O(n)       | FIFO，队尾入队，队首出队     |
| **双端队列 (Deque)**    | O(1)两端      | O(n)                  | O(1)两端              | O(1)两端              | O(n)       | 两端都可插入删除             |
| **哈希表 (Hash Table)** | -             | O(1)平均<br/>O(n)最坏 | O(1)平均<br/>O(n)最坏 | O(1)平均<br/>O(n)最坏 | O(n)       | 哈希冲突影响性能             |

### 解决哈希冲突

- 开放寻址法：1. 线性探测：发生冲突时，依次检查下一个位置 2. 二次探测：使用二次函数计算，负载因子较低时，内存使用效率要求高，缓存性能重要
- 链地址法：将哈希到同一位置的元素存储在链表中，适合不确定数据量大小的场景，内存充足
- 再哈希法：使用多个哈希函数，当第一个产生冲突时使用第二个
- 公共溢出区：将所有冲突的元素存放在单独的溢出区域

### 面向对象三大特性

1. 继承：使用现有类的功能，并可以对这些功能进行扩展
2. 封装：将客观事物封装成抽象类，类可以吧自己的数据和方法只让可信类和对象操作，比如使用public、private修饰
3. 多态：同一事物表现不同事物的能力，重载实现编译时多态，需函数实现运行时多态

### C++的多态如何实现

在基类的函数前加上virtual关键字，在派生类中重写该函数，运行时会根据对象的实际类型来调用相应的函数。

实现多态的过程：

1. 编译器发现基类有需函数，自动为每个有需函数的类生成一份虚表，是一个一位数组，虚表里保存了虚函数的入口地址
2. 编译器会在每个对象的前四个字节中保存一个虚表指针，即vptr，指向对象所属类的虚表。在构造时，根据对象的类型去初始化虚表指针，从而让虚表指针指向正确的虚表，从而能调用正确的虚函数
3. 在派生类定义对象时，程序运行会自动调用构造函数，在构造函数中创建并初始化虚表。
4. 当派生类对基类的虚函数没有重写，虚表指针指向基类的虚表，重写时，指向自身的虚表，这样就可以根据重写情况进行动态调用，从而实现多态性。

虚表存在只读数据段(.rodata)，虚函数位于代码段(.text)

### 为什么析构函数写成虚函数

基类指针可以指向派生类对象，如果删除基类的指针，就会调用指向的派生类的析构函数，而派生类析构函数又会自动调用基类析构函数，如果析构函数不被声明为虚函数，实施静态绑定，在删除基类指针时，只会调用基类析构函数，派生类对象析构不完全，造成内存泄露。

### 构造函数能否声明为虚函数或者纯虚函数

- 创建一个对象时需要确定对象类型，而虚函数是运行时动态确定类型的，构造对象时，对象还未创建成功，编译器是无法知道对象的实际类型
- 虚函数对应一个虚表，类中存一个虚表指针，如果构造函数是虚函数，就需要通过虚表调用，但是对象未初始化没有虚表指针，找不到虚表，所以构造函数不能是虚函数
- 构造函数是创建对象时调用的，不可能通过父类或者引用去调用，使用不会是虚函数

### 构造函数和析构函数能调用虚函数吗

- 构造函数：父类在子类之前进行构造，此时子类还未完全初始化，调用虚函数是不安全的
- 析构函数：用来销毁对象，先调用子类析构，再调用基类，调用基类析构函数时，子类对象已经销毁，再调用虚函数没有意义

### 构造函数执行顺序

1. 虚拟基类的构造函数（多个虚拟基类则按照继承的顺序执行构造函数）。
2. 基类的构造函数（多个普通基类也按照继承的顺序执行构造函数）。
3. 类类型的成员对象的构造函数（按照成员对象在类中的声明顺序）
4. 派生类自己的构造函数。

### 析构函数执行顺序

1. 派生类自己的析构函数
2. 类类型的成员对象的析构函数
3. 基类的析构函数
4. 虚拟基类的析构函数

### 构造函数和析构函数能否抛异常

- 构造函数：构造函数中发生异常，控制权转出构造函数之外，析构函数不会调用，会造成内存泄露（采用智能指针，初始化列表构造）
- 析构函数：如果日常从析构函数抛出，那析构函数执行不全，会存在内存泄露问题

### 构造函数、拷贝构造函数和赋值操作符

- 构造函数：对象不存在，创建一个新的对象时调用构造函数
- 拷贝构造函数：对象不存在，使用别的已存在对象初始化
- 赋值运算符：对象存在，用别的对象给他赋值

### 拷贝构造函数和赋值运算符

- 拷贝构造函数是函数，赋值运算符是运算符重载
- 拷贝构造函数会生成新的对象，赋值运算符不行

### 拷贝构造函数必须传引用而不能传值

用传值的方式传参数，构造实参需要调用拷贝构造函数，而拷贝构造函数需要传递实参，会无限递归

### 虚函数的代价

1. 会产生一个虚函数表，用来存储指向虚函数的指针
2. 每一个对象会有一个指向虚表的虚表指针，增加对象的空间大小
3. 不能再是内联函数，内联函数在编译阶段替代，而虚函数需要等运行阶段确定

### 哪些函数不能是虚函数

1. 构造函数。
2. 内联函数：内联函数表示在编译阶段进行函数体的替换操作，虚函数意味着在运行期间动态确定类型
3. 静态函数：静态函数不属于对象属于类，没有this指针，设置为虚函数没有意义
4. 友元函数：不属于类的成员函数，不能被继承
5. 普通函数：不属于类的成员函数，没有继承特性

### 移动构造函数

场景：使用对象a初始化对象b后对象a不再使用，单对象a的空间还在，拷贝构造函数是将a的内容复制一份到b中，这时候想直接使用a的空间，就要用到移动构造函数。

当移动值的对象是临时变量，或者直接使用move将左值转化为右值，触发移动语义

### C++内存分区

- 栈：执行函数时，存储局部变量，函数执行结束时自动被释放
- 堆：需要new出来的内存块，他们的释放由程序控制
- 全局/静态存储区：全局变量和静态变量被分到同一块内存中
- 常量存储区：存放常量字符串
- 代码区：存放函数体的二进制代码

### this指针

- this指针是类的指针，指向对象首地址
- this指针只能在成员函数中使用，在全局函数、静态成员函数中不能使用
- this指针只有在成员函数中才有定义
- 使用delete this时，类对象的内存空间被释放，之后的其他函数调用，只要不涉及到this指针内容，都能正常运行，一旦涉及到this指针，如调用虚函数等，就会出现不可预期问题
- 如果在析构函数中调用delete this，delete的本质就是调用析构函数，这样就会无限递归，堆栈溢出

### 类对象的大小受哪些因素影响

1. 类的非静态成员变量大小，静态成员和成员函数不占据类空间大小
2. 内存对齐另外分配的空间大小
3. 虚函数的话，会在类对象插入vptr指针，加上指针大小
4. 当该类是某类的派生类，那么派生类继承的基类部分的数据成员也会存在在派生类的空间中，也会对派生类进行扩展

### 在main执行之前和之后执行

执行之前，主要是初始化系统相关资源

- 设置栈指针
- 初始化静态和全局变量，即.data内容
- 将为初始化部分的全局变量赋初值，即.bss内容
- 全局对象初始化，在main之前调用构造函数

执行之后

- 全局对象的析构函数

### 内存对齐

- 分配内存的顺序按照声明的顺序
- 每个变量相对于起始位置的偏移量必须是变量类型大小的整数倍
- 整个结构体大小必须是变量类型最大值的整数倍

```c++
struct Info {
  uint8_t a;   // 1 byte
  uint16_t b;  // 2 bytes (需2字节对齐)
  uint8_t c;   // 1 byte
};

Offset 0: a (1 byte)
Offset 1: [padding] (1 byte)  // 填充，确保 b 从 Offset 2 开始
Offset 2: b (2 bytes)
Offset 4: c (1 byte)
Offset 5: [padding] (1 byte)  // 填充，使结构体大小为对齐值的整数倍
```

### 指针和引用

- 指针是一个变量，存的是一个地址，引用和原来变量本质上是一个东西，是原变量别名
- 指针可以有多级，引用只能一级
- 指针可以为空，引用不能为NULL且定义时必须初始化
- 指针初始化后可以改变指向，引用不可变
- 指针作为参数传递，是将实参的拷贝给行参，指向地址相同但不是一个变量，不影响实参，而引用可以

### 常量指针和指针常量

- 常量指针是一个指针，指向一个只读变量，int const *p或const int *p，const修饰 *p
- 指针常量是一个不能改变方向的指针，即int *const p，const修饰 p（指针本身）

### 堆和栈

- 栈由系统自动分配，速度快，不会有碎片，是一块连续的内存区域
- 堆是自己申请和释放，速度慢，会有碎片，是不连续的内存区域

### 指针数组

```c++
int *p[10] //一个包含 10 个 int*（整型指针）的数组，存储多个指针（如字符串数组）
int (*p)[10]//一个指向 int[10]（10 个整型的数组）的指针，操作整个数组（如二维数组）
int *p(int)//一个函数声明，函数名为 p，接受一个 int 参数，返回 int*（整型指针），函数返回指针（需谨慎）
int (*p)(int)//一个函数指针，指向一个接受 int 参数并返回 int 的函数，动态调用函数（回调机制）

```

### new/delete和malloc/free

- 前者是C++运算符，后者是标准库函数
- new要自动计算分配空间大小，malloc需要手工计算
- new是类型安全的，操作成功返回的是对象类型的指针，malloc不是，操作成功返回的是void *
- malloc和free分配和回收内存空间，new和delete还会调用构造函数和析构函数
- new封装了malloc，直接free不会报错，但这只是释放内存，没有析构对象

### strlen和sizeof

| 特性              | `strlen`                               | `sizeof`                 |
| ----------------- | -------------------------------------- | ------------------------ |
| **作用**          | 计算字符串长度（不含 `\0`）            | 计算变量/类型的内存大小  |
| **适用对象**      | 仅 C 风格字符串（`char*` 或 `char[]`） | 任何变量或类型           |
| **是否计算 `\0`** | 不计算                                 | 计算（如果是字符串）     |
| **计算时机**      | 运行时（遍历字符串）                   | 编译时（直接替换为常量） |

```c++
  int main(int argc, char const *argv[]){
      
      const char* str = "name";

      sizeof(str); // 取的是指针str的长度，是8(64位)
      strlen(str); // 取的是这个字符串的长度，不包含结尾的 \0。大小是4
      return 0;
  }
```

### a和&a

```c++
    int a[10] = {10, 20, 30, 40, 50, 60, 70, 80, 90, 100};
    int (*p)[10] = &a;  // p 是指向数组 a 的指针

    // 1. 验证 a 和 &a 的地址
    printf("a = %p\n", a);         // 输出 a[0] 的地址（如 0x00000001）
    printf("a + 1 = %p\n", a + 1); // 输出 a[1] 的地址（如 0x00000005）
    printf("&a = %p\n", &a);       // 输出数组 a 的起始地址（同 a[0]）
    printf("&a + 1 = %p\n", &a + 1); // 输出数组末尾的下一个地址（如 0x00000029）

    // 2. 通过 p 访问数组元素
    printf("(*p)[0] = %d\n", (*p)[0]); // 输出 a[0]（10）
    printf("(*p)[1] = %d\n", (*p)[1]); // 输出 a[1]（20）

    // 3. 强制转换 p 为 int*
    int *ptr = (int *)p;
    printf("*ptr = %d\n", *ptr);       // 输出 a[0]（10）
    printf("*(ptr + 1) = %d\n", *(ptr + 1)); // 输出 a[1]（20）
```

### 数组名和指针

- 都可以通过增减偏移量来访问数组中的元素
- 数组名不是真正意义上的指针，可以理解为常指针，无自增自减
- 当数组名当做形参传递给调用函数后，就失去原有特性，退化为一般指针，sizeof不能得到原数组大小

野指针和悬空指针

- 野指针：没有被初始化的指针
- 悬空指针：指向的内存已经被释放的指针

### 重载和重写

- 重载：函数名相同，参数类型和数目不同，根据参数类型来选择函数体
- 重写：在派生类覆盖基类中的同名函数，重写函数体，有相同的参数个数，参数类型，返回值类型，根据对象类型选择函数体

### C++构造函数

```c++
#include <iostream>
using namespace std;

class Student{
public:
    Student(){//默认构造函数，没有参数
        this->age = 20;
        this->num = 1000;
    };  
    Student(int a, int n):age(a), num(n){}; //初始化构造函数，有参数和参数列表
    Student(const Student& s){//拷贝构造函数，这里与编译器生成的一致
        this->age = s.age;
        this->num = s.num;
    }; 
    Student(int r){   //转换构造函数,形参是其他类型变量，且只有一个形参
        this->age = r;
		this->num = 1002;
    };
    Student(const char* name, double score)// 接受任意类型指定参数的构造函数，
    {
        this->age = 0;
        this->num = (int)score;
    }
    Student(double r){   //转换构造函数,形参是其他类型变量，且只有一个形参
        this->age = (int)r * 10;
		this->num = 1003;
    };
    ~Student(){}
public:
    int age;
    int num;
};

int main(){
    Student s1;
    Student s2(18,1001);//初始化构造函数调用
    int a = 10;
    Student s3(a);//重载构造函数调用,传参数形式
    Student s4(s3);
    Student s5("Demo",56.45);//重载构造函数调用
    Student s6 = 85.63;//证明为转换构造函数调用
    float b = 5.2;
    Student s7 = b;//为转换构造函数调用，带有隐式类型转换
	
    
    printf("s1 age:%d, num:%d\n", s1.age, s1.num);
    printf("s2 age:%d, num:%d\n", s2.age, s2.num);
    printf("s3 age:%d, num:%d\n", s3.age, s3.num);
    printf("s4 age:%d, num:%d\n", s4.age, s4.num);
    printf("s5 age:%d, num:%d\n", s5.age, s5.num);
    printf("s6 age:%d, num:%d\n", s6.age, s6.num);
    printf("s7 age:%d, num:%d\n", s7.age, s7.num);
    return 0;
}
//运行结果
//s1 age:20, num:1000
//s2 age:18, num:1001
//s3 age:10, num:1002
//s4 age:10, num:1002
//s5 age:0, num:56
//s6 age:850, num:1003
//s7 age:50, num:1003

```

### 深拷贝与浅拷贝

- 浅拷贝：拷贝一个指针，并没有开辟新地址，如果原来指针指向资源被释放，那么再释放浅拷贝指针的资源就会报错
- 深拷贝：不仅拷贝值，还开辟一块新的空间用来存放新值，有指针变量的话需要自己实现深拷贝

### public，protected和private访问和继承权限

- public的变量和函数在类的内部外部都可以访问，公有继承的特点是基类的公有成员和保护成员作为派生类的成员时，都保持原有的状态，而基类的私有成员任然是私有的，不能被这个派生类的子类所访问
- protected的变量和函数只能在类的内部和派生类中访问，保护继承的特点是基类的所有公有成员和保护成员都成为派生类的保护成员，并且只能被它的派生类成员函数或友元函数访问，基类的私有成员仍然是私有的
- private修饰的元素只能在类内访问，私有继承的特点是基类的所有公有成员和保护成员都成为派生类的私有成员，并不被它的派生类的子类所访问，基类的成员只能由自己派生类访问，无法再往下继承

### 大小端存储

- 大端存储：高字节存储在低地址（socket）
- 小端存储：低字节存储在低地址（操作系统）

```c++
#include <iostream>
using namespace std;
int main()
{
    int a = 0x1234;
    //由于int和char的长度不同，借助int型转换成char型，只会留下低地址的部分
    char c = (char)(a);
    if (c == 0x12)
        cout << "big endian" << endl;
    else if(c == 0x34)
        cout << "little endian" << endl;
}

```

### 值传递、指针传递和引用传递

- 值传递：有一个形参向函数所属的栈拷贝数据的过程
- 指针传递，有一个形参向函数所属的栈拷贝四字节地址的过程，传的是地址值
- 引用传递，为该数据所在地址取了个别名，传地址，不能返回局部变量的引用

### 内存泄露

一般是指堆内存的泄漏，分配了内存后，必须相应的调用delete或free释放内存块，不然就会内存泄漏

### 指针加减

```c++
#include <iostream>
using namespace std;

int main()
{
	int *a, *b, c;
	a = (int*)0x500;
	b = (int*)0x520;
	c = b - a;//两个指针之间的元素个数，而不是直接的地址差值
	printf("%d\n", c); // 8
	a += 0x020;//指针移动的单位是 类型大小，而不是字节，实际为0x020 * sizeof(int)
	c = b - a;
	printf("%d\n", c); // -24
	return 0;
}

```

### 函数调用过程栈的变化

1. 参数按从右向左的顺序压栈，为了支持可变参数函数（如 printf），第一个参数（格式字符串）最后压栈，便于定位
2. 执行call命令，将返回地址压栈
3. 保存当前的栈帧的基址ebp，再标记栈顶esp
4. 开始存放被调函数的变量

### 定义和声明

- 变量：声明就是告诉编译器有个类型的变量会被使用，但不会分配内存，定义就是分配了内存
- 函数：声明一般在头文件里，就是告诉编译器有这么个函数的存在，定义在源文件中，就是写明函数体

### static变量和全局变量

- static：static全局变量只在定义该变量的源文件内有效，static函数作用域只在本文件中，static函数在内存中只有一份，普通函数在每个调用中都会拷贝一份
- 全局变量：用extern就可跨文件使用

### C++从代码到可执行程序经历了什么

1. 预编译：展开头文件，处理宏定义，删除注释
2. 编译：语法语义分析，优化，生成汇编代码
3. 汇编：把汇编代码转变为机器码
4. 链接：将不同源文件产生的目标文件进行链接，形成可执行程序
   - 动态链接：把程序按照模块拆分成各个独立部分，程序运行时才链接到一起
   - 静态链接：把所有程序模块都链接成一个单独的可执行文件

